"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateopenmate_ui"]("main_window",{

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n// =======================\n// State Management\n// =======================\nconst AppState = {\n  repos: [],\n  collections: [],\n\n  setRepos(repos) {\n    this.repos = repos;\n  },\n\n  setCollections(collections) {\n    this.collections = collections;\n  },\n\n  getFilteredRepos(searchTerm) {\n    return this.filterItems(this.repos, searchTerm);\n  },\n\n  getFilteredCollections(searchTerm) {\n    return this.filterItems(this.collections, searchTerm);\n  },\n\n  filterItems(items, searchTerm) {\n    if (!searchTerm) return items;\n    const term = searchTerm.toLowerCase();\n    return items.filter(\n      (item) =>\n        item.name.toLowerCase().includes(term) ||\n        (item.path && item.path.toLowerCase().includes(term)) ||\n        (item.repos && item.repos.toLowerCase().includes(term))\n    );\n  },\n};\n\n// =======================\n// Utility Functions\n// =======================\nconst Utils = {\n  formatPath(path) {\n    return path ? path.replace(/\\\\/g, \"/\") : \"\";\n  },\n\n  debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  },\n\n  createElement(tag, attributes = {}, children = []) {\n    const element = document.createElement(tag);\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (key === \"className\") {\n        element.className = value;\n      } else {\n        element.setAttribute(key, value);\n      }\n    });\n    children.forEach((child) => {\n      if (typeof child === \"string\") {\n        element.appendChild(document.createTextNode(child));\n      } else {\n        element.appendChild(child);\n      }\n    });\n    return element;\n  },\n};\n\n// =======================\n// Storage Management\n// =======================\nconst Storage = {\n  THEME_KEY: \"openmate-theme\",\n  IDE_KEY: \"openmate-ide-selector\",\n\n  get(key) {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      console.warn(\"Storage get failed:\", e);\n      return null;\n    }\n  },\n\n  set(key, value) {\n    try {\n      localStorage.setItem(key, value);\n    } catch (e) {\n      console.warn(\"Storage set failed:\", e);\n    }\n  },\n};\n\n// =======================\n// Theme Management\n// =======================\nconst ThemeManager = {\n  init() {\n    this.themeToggle = document.getElementById(\"theme-toggle\");\n    this.themeIcon = document.querySelector(\".theme-icon\");\n\n    this.loadTheme();\n    this.bindEvents();\n  },\n\n  loadTheme() {\n    const savedTheme = Storage.get(Storage.THEME_KEY);\n    const systemPrefersDark = window.matchMedia(\n      \"(prefers-color-scheme: dark)\"\n    ).matches;\n    const theme = savedTheme || (systemPrefersDark ? \"dark\" : \"light\");\n\n    this.setTheme(theme);\n  },\n\n  setTheme(theme) {\n    document.documentElement.setAttribute(\"data-theme\", theme);\n    this.themeIcon.textContent = theme === \"dark\" ? \"☀️\" : \"🌙\";\n    Storage.set(Storage.THEME_KEY, theme);\n  },\n\n  toggle() {\n    const currentTheme = document.documentElement.getAttribute(\"data-theme\");\n    const newTheme = currentTheme === \"dark\" ? \"light\" : \"dark\";\n    this.setTheme(newTheme);\n  },\n\n  bindEvents() {\n    this.themeToggle.addEventListener(\"click\", () => this.toggle());\n  },\n};\n\n// =======================\n// IDE Selector Management\n// =======================\nconst IDEManager = {\n  init() {\n    this.selector = document.getElementById(\"ide-selector\");\n    this.loadPreference();\n    this.bindEvents();\n  },\n\n  loadPreference() {\n    const savedIDE = Storage.get(Storage.IDE_KEY);\n    if (savedIDE) {\n      this.selector.value = savedIDE;\n    }\n  },\n\n  getSelectedIDE() {\n    return this.selector.value;\n  },\n\n  bindEvents() {\n    this.selector.addEventListener(\"change\", (e) => {\n      const selectedIDE = e.target.value;\n      if (selectedIDE) {\n        Storage.set(Storage.IDE_KEY, selectedIDE);\n        NotificationManager.showSuccess(`Default IDE set to ${selectedIDE}`);\n      }\n    });\n  },\n};\n\n// =======================\n// Notification Management\n// =======================\nconst NotificationManager = {\n  show(message, type = \"info\", duration = 3000) {\n    const colors = {\n      success: \"#4CAF50\",\n      error: \"#F44336\",\n      info: \"#2196F3\",\n    };\n\n    const notification = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        bottom: 20px;\n        right: 20px;\n        padding: 10px 20px;\n        background: ${colors[type]};\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n        transition: opacity 0.3s ease;\n      `,\n      },\n      [message]\n    );\n\n    document.body.appendChild(notification);\n\n    setTimeout(() => {\n      notification.style.opacity = \"0\";\n      setTimeout(() => {\n        if (document.body.contains(notification)) {\n          document.body.removeChild(notification);\n        }\n      }, 300);\n    }, duration);\n  },\n\n  showSuccess(message) {\n    this.show(message, \"success\");\n  },\n\n  showError(message) {\n    this.show(message, \"error\");\n  },\n\n  showInfo(message) {\n    this.show(message, \"info\");\n  },\n};\n\n// =======================\n// Modal Management\n// =======================\nclass Modal {\n  constructor(modalId, formId, openBtnId) {\n    this.modal = document.getElementById(modalId);\n    this.form = document.getElementById(formId);\n    this.openBtn = document.getElementById(openBtnId);\n    this.closeBtn = this.modal.querySelector(\".close\");\n\n    this.bindEvents();\n  }\n\n  bindEvents() {\n    this.openBtn?.addEventListener(\"click\", () => this.open());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n\n    // Close on outside click\n    window.addEventListener(\"click\", (e) => {\n      if (e.target === this.modal) {\n        this.close();\n      }\n    });\n\n    // Close on Escape key\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Escape\" && this.isOpen()) {\n        this.close();\n      }\n    });\n  }\n\n  open() {\n    this.modal.style.display = \"flex\";\n    document.body.style.overflow = \"hidden\";\n    this.onOpen();\n  }\n\n  close() {\n    this.modal.style.display = \"none\";\n    document.body.style.overflow = \"auto\";\n    this.form?.reset();\n    this.onClose();\n  }\n\n  isOpen() {\n    return this.modal.style.display === \"flex\";\n  }\n\n  onOpen() {\n    // Override in subclasses\n  }\n\n  onClose() {\n    // Override in subclasses\n  }\n}\n\n// =======================\n// Repository Modal\n// =======================\nclass RepositoryModal extends Modal {\n  constructor() {\n    super(\"add-repo-modal\", \"add-repo-form\", \"add-repo-btn\");\n    this.nameInput = document.getElementById(\"repo-name\");\n    this.pathInput = document.getElementById(\"repo-path\");\n    this.browseBtn = document.getElementById(\"browse-path\");\n\n    this.bindRepositoryEvents();\n  }\n\n  onOpen() {\n    this.nameInput.focus();\n  }\n\n  bindRepositoryEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn.addEventListener(\"click\", () => this.browsePath());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const path = this.pathInput.value.trim();\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      await window.electronAPI.addRepository({ name, path });\n      this.close();\n      NotificationManager.showSuccess(\"Repository added successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error adding repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name || !path) {\n      NotificationManager.showError(\"Please fill in all fields\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Repository Modal\n// =======================\nclass EditRepositoryModal extends Modal {\n  constructor() {\n    super(\"edit-repo-modal\", \"edit-repo-form\");\n    this.nameInput = document.getElementById(\"edit-repo-name\");\n    this.pathInput = document.getElementById(\"edit-repo-path\");\n    this.originalNameInput = document.getElementById(\"edit-original-name\");\n    this.browseBtn = document.getElementById(\"edit-browse-path\");\n    this.closeBtn = document.querySelector(\"#edit-repo-modal .close\");\n\n    this.bindEvents();\n  }\n\n  open(repo) {\n    // Store original values\n    this.originalNameInput.value = repo.name;\n\n    // Set current values (read-only)\n    document.getElementById(\"current-repo-name\").textContent = repo.name;\n    document.getElementById(\"current-repo-path\").textContent = repo.path;\n\n    // Clear and reset form fields\n    this.nameInput.value = repo.name;\n    this.pathInput.value = repo.path;\n    this.nameInput.placeholder = `Current: ${repo.name}`;\n    this.pathInput.placeholder = `Current: ${repo.path}`;\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn?.addEventListener(\"click\", () => this.browsePath());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim() || originalName; // Use original name if new name is empty\n    const path =\n      this.pathInput.value.trim() ||\n      this.pathInput.placeholder.replace(\"Current: \", \"\"); // Use current path if empty\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      // Get current repositories data\n      const data = await window.electronAPI.getReposData();\n\n      // Ensure we have the expected data structure\n      if (!data || typeof data !== \"object\" || !data.repos) {\n        throw new Error(\"Invalid repository data structure\");\n      }\n\n      console.log(\"Current repositories:\", data.repos); // Debug log\n      console.log(\"Looking for repository with name:\", originalName); // Debug log\n\n      // Check if the repository exists\n      if (!data.repos[originalName]) {\n        console.error(\"Repository not found in:\", data.repos);\n        throw new Error(\"Repository not found\");\n      }\n\n      // Check if name is being changed to an existing one (except current repo)\n      if (name !== originalName && data.repos[name]) {\n        NotificationManager.showError(\n          \"A repository with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the repositories\n      const updatedRepos = { ...data.repos };\n\n      // If name changed, remove old entry\n      if (name !== originalName) {\n        delete updatedRepos[originalName];\n      }\n\n      // Update or add the repository with new values and updatedAt timestamp\n      const now = new Date().toISOString();\n      updatedRepos[name] = {\n        path,\n        updatedAt: data.repos[originalName]?.updatedAt || now,\n      };\n\n      // Save the updated repositories using the correct IPC method\n      await window.electronAPI.writeReposFile({\n        ...data,\n        repos: updatedRepos,\n      });\n\n      // Refresh UI\n      UIManager.refresh();\n\n      NotificationManager.showSuccess(\"Repository updated successfully\");\n      this.close();\n    } catch (error) {\n      console.error(\"Error updating repository:\", error);\n      NotificationManager.showError(\n        `Failed to update repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a repository name\");\n      return false;\n    }\n    if (!path) {\n      NotificationManager.showError(\"Please select a repository path\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Collection Modal\n// =======================\nclass EditCollectionModal extends Modal {\n  constructor() {\n    super(\"edit-collection-modal\", \"edit-collection-form\");\n    this.nameInput = document.getElementById(\"edit-collection-name\");\n    this.originalNameInput = document.getElementById(\n      \"edit-original-collection-name\"\n    );\n    this.currentNameEl = document.getElementById(\"current-collection-name\");\n    this.currentReposEl = document.getElementById(\"current-collection-repos\");\n    this.reposSelection = document.getElementById(\"edit-repos-selection\");\n    this.closeBtn = document.querySelector(\"#edit-collection-modal .close\");\n\n    this.bindEvents();\n  }\n\n  async open(collection) {\n    // Store original values\n    this.originalNameInput.value = collection.name;\n\n    // Set current values\n    this.currentNameEl.textContent = collection.name;\n\n    // Handle both array and string formats for backward compatibility\n    const repoList = Array.isArray(collection.repos)\n      ? collection.repos\n      : (collection.repos || \"\")\n          .split(\",\")\n          .map((s) => s.trim())\n          .filter(Boolean);\n\n    this.currentReposEl.textContent = repoList.length\n      ? repoList.join(\", \")\n      : \"No repositories\";\n    this.nameInput.value = collection.name;\n    this.nameInput.placeholder = `Current: ${collection.name}`;\n\n    // Load repositories with current selection\n    await this.loadRepositories(repoList);\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async loadRepositories(selectedRepos = []) {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {}, selectedRepos);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos, selectedRepos = []) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"edit-repo-${name}\" name=\"repos\" value=\"${name}\" \n                 ${selectedRepos.includes(name) ? \"checked\" : \"\"}>\n          <label for=\"edit-repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      const data = await window.electronAPI.getReposData();\n\n      // Check if name is being changed to an existing one (except current collection)\n      if (name !== originalName && data.collections && data.collections[name]) {\n        NotificationManager.showError(\n          \"A collection with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the collections\n      const updatedCollections = { ...data.collections };\n\n      // Remove old entry if name changed\n      if (name !== originalName) {\n        delete updatedCollections[originalName];\n      }\n\n      // Update or add the collection with new values\n      updatedCollections[name] = {\n        name,\n        repos: selectedRepos, // Save as array\n        updatedAt:\n          updatedCollections[originalName]?.updatedAt ||\n          new Date().toISOString(),\n      };\n\n      // Save the updated collections\n      await window.electronAPI.writeReposFile({\n        ...data,\n        collections: updatedCollections,\n      });\n\n      this.close();\n      NotificationManager.showSuccess(\"Collection updated successfully\");\n      UIManager.refresh();\n    } catch (error) {\n      console.error(\"Error updating collection:\", error);\n      NotificationManager.showError(\n        `Failed to update collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// =======================\n// Collection Modal\n// =======================\nclass CollectionModal extends Modal {\n  constructor() {\n    super(\"add-collection-modal\", \"add-collection-form\", \"add-collection-btn\");\n    this.nameInput = document.getElementById(\"collection-name\");\n    this.reposSelection = document.getElementById(\"repos-selection\");\n\n    this.bindCollectionEvents();\n  }\n\n  async onOpen() {\n    this.nameInput.focus();\n    await this.loadRepositories();\n  }\n\n  onClose() {\n    this.reposSelection.innerHTML =\n      '<div class=\"loading\">Loading repositories...</div>';\n  }\n\n  bindCollectionEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n  }\n\n  async loadRepositories() {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {});\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"repo-${name}\" name=\"repos\" value=\"${name}\">\n          <label for=\"repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      await this.saveCollection(name, selectedRepos);\n      this.close();\n      NotificationManager.showSuccess(\"Collection created successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error creating collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n\n  async saveCollection(name, selectedRepos) {\n    const data = await window.electronAPI.getReposData();\n\n    if (data.collections && data.collections[name]) {\n      throw new Error(\"A collection with this name already exists\");\n    }\n\n    if (!data.collections) data.collections = {};\n    data.collections[name] = {\n      name,\n      repos: selectedRepos,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await window.electronAPI.writeReposFile(data);\n  }\n}\n\n// =======================\n// UI Management\n// =======================\nconst UIManager = {\n  init(callbacks = {}) {\n    this.searchInput = document.getElementById(\"search-input\");\n    this.refreshBtn = document.getElementById(\"refresh-btn\");\n\n    // Store callbacks\n    this.handleEditRepository = callbacks.onEditRepository || (() => {});\n    this.handleEditCollection = callbacks.onEditCollection || (() => {});\n\n    // Initialize edit collection modal if it doesn't exist\n    if (!this.editCollectionModal) {\n      this.editCollectionModal = new EditCollectionModal();\n    }\n\n    this.bindEvents();\n    this.refresh();\n  },\n\n  bindEvents() {\n    // Debounce search to improve performance\n    const debouncedUpdate = Utils.debounce(() => this.updateDisplay(), 300);\n    this.searchInput.addEventListener(\"input\", debouncedUpdate);\n    this.refreshBtn.addEventListener(\"click\", () => this.refresh());\n  },\n\n  async refresh() {\n    this.showRefreshAnimation();\n\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.processData(data);\n      this.updateDisplay();\n    } catch (error) {\n      NotificationManager.showError(`Error refreshing data: ${error.message}`);\n    } finally {\n      this.hideRefreshAnimation();\n    }\n  },\n\n  processData(data) {\n    // Process repositories\n    if (data.repos) {\n      const repos = Object.entries(data.repos).map(([name, repo]) => ({\n        name,\n        path: repo.path,\n        updatedAt: repo.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setRepos(repos);\n    } else {\n      AppState.setRepos([]);\n    }\n\n    // Process collections\n    if (data.collections) {\n      const collections = Object.values(data.collections).map((collection) => ({\n        name: collection.name,\n        repos: Array.isArray(collection.repos)\n          ? collection.repos.join(\", \")\n          : \"\",\n        updatedAt: collection.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setCollections(collections);\n    } else {\n      AppState.setCollections([]);\n    }\n  },\n\n  updateDisplay() {\n    const searchTerm = this.searchInput.value.trim();\n    this.updateRepositoriesTable(AppState.getFilteredRepos(searchTerm));\n    this.updateCollectionsTable(AppState.getFilteredCollections(searchTerm));\n  },\n\n  updateRepositoriesTable(repos) {\n    const container = document.getElementById(\"repos-list\");\n    const table = document.getElementById(\"repos-table\");\n    const loading = document.getElementById(\"loading-repos\");\n\n    if (repos.length === 0) {\n      loading.textContent = \"No matching repositories found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = repos\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((repo) => this.createRepositoryRow(repo))\n      .join(\"\");\n\n    this.bindRepositoryEvents();\n  },\n\n  createRepositoryRow(repo) {\n    return `\n      <tr data-path=\"${Utils.formatPath(repo.path)}\" class=\"clickable-repo-row\">\n        <td><strong>${repo.name}</strong></td>\n        <td class=\"path\">${Utils.formatPath(repo.path)}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${repo.name}\" data-path=\"${Utils.formatPath(repo.path)}\" data-type=\"repo\" title=\"Edit repository\">✏️</button>\n            <button class=\"delete-btn\" data-name=\"${repo.name}\" data-type=\"repo\" title=\"Delete repository\">🗑️</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindRepositoryEvents() {\n    // Bind click events for opening repositories\n    document.querySelectorAll(\".clickable-repo-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleRepositoryClick(e, row));\n    });\n\n    // Bind edit events\n    document.querySelectorAll('.edit-btn[data-type=\"repo\"]').forEach((btn) => {\n      btn.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        const name = btn.dataset.name;\n        const path = btn.dataset.path;\n        if (this.handleEditRepository) {\n          this.handleEditRepository({ name, path });\n        }\n      });\n    });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"repo\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleRepositoryDelete(e, btn)\n        );\n      });\n  },\n\n  async handleRepositoryClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    const selectedIDE = IDEManager.getSelectedIDE();\n    if (!selectedIDE) {\n      NotificationManager.showError(\"Please select an IDE first\");\n      return;\n    }\n\n    const repoPath = row.getAttribute(\"data-path\");\n    if (!repoPath) return;\n\n    try {\n      const result = await window.electronAPI.openInIDE({\n        name: row.getAttribute(\"data-name\"),\n        path: repoPath,\n        ide: selectedIDE,\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || \"Failed to open in IDE\");\n      }\n\n      NotificationManager.showSuccess(\n        `Successfully opened ${repoPath} in ${selectedIDE}`\n      );\n    } catch (error) {\n      NotificationManager.showError(`Error opening IDE: ${error.message}`);\n    }\n  },\n\n  async handleRepositoryDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete repository \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteRepo(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  updateCollectionsTable(collections) {\n    const container = document.getElementById(\"collections-list\");\n    const table = document.getElementById(\"collections-table\");\n    const loading = document.getElementById(\"loading-collections\");\n\n    if (collections.length === 0) {\n      loading.textContent = \"No matching collections found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = collections\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((collection) => this.createCollectionRow(collection))\n      .join(\"\");\n\n    this.bindCollectionEvents();\n  },\n\n  createCollectionRow(collection) {\n    const collectionData = JSON.stringify(collection).replace(/\"/g, \"&quot;\");\n    return `\n      <tr class=\"clickable-collection-row\" data-collection=\"${collectionData}\">\n        <td><strong>${collection.name}</strong></td>\n        <td>${collection.repos}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Edit collection\">✏️</button>\n            <button class=\"delete-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Delete collection\">🗑️</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindCollectionEvents() {\n    // Bind click events for opening collections\n    document.querySelectorAll(\".clickable-collection-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleCollectionClick(e, row));\n    });\n\n    // Bind edit events\n    document\n      .querySelectorAll('.edit-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          const collectionData = JSON.parse(\n            btn\n              .closest(\"tr\")\n              .getAttribute(\"data-collection\")\n              .replace(/&quot;/g, '\"')\n          );\n          if (this.editCollectionModal) {\n            this.editCollectionModal.open(collectionData);\n          }\n        });\n      });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleCollectionDelete(e, btn)\n        );\n      });\n  },\n\n  async handleCollectionClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    try {\n      const collection = JSON.parse(row.getAttribute(\"data-collection\"));\n      const reposData = await window.electronAPI.getReposData();\n\n      const repos = collection.repos.split(\",\").map((repo) => {\n        const [name, path, ide] = repo\n          .trim()\n          .split(\"|\")\n          .map((s) => s.trim());\n        return { name, path, ide };\n      });\n\n      // Open all repositories in parallel\n      const promises = repos.map(async (repo) => {\n        const repoData = reposData.repos[repo.name];\n\n        if (!repoData) {\n          NotificationManager.showError(\n            `${repo.name}: Not found in repositories`\n          );\n          return;\n        }\n\n        const ide = repo.ide || IDEManager.getSelectedIDE();\n\n        try {\n          await window.electronAPI.openInIDE({\n            name: repo.name,\n            path: repoData.path,\n            ide: ide,\n          });\n        } catch (error) {\n          NotificationManager.showError(\n            `Failed to open ${repo.name}: ${error.message}`\n          );\n        }\n      });\n\n      await Promise.allSettled(promises);\n      NotificationManager.showSuccess(`Successfully opened ${collection.name}`);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error processing collection: ${error.message}`\n      );\n    }\n  },\n\n  async handleCollectionDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete collection \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteCollection(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  showRefreshAnimation() {\n    this.refreshBtn.classList.add(\"rotating\");\n  },\n\n  hideRefreshAnimation() {\n    setTimeout(() => {\n      this.refreshBtn.classList.remove(\"rotating\");\n    }, 1000);\n  },\n\n  showLoadingIndicator(text) {\n    const indicator = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        padding: 10px;\n        background: rgba(0,0,0,0.7);\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n      `,\n      },\n      [text]\n    );\n\n    document.body.appendChild(indicator);\n    return indicator;\n  },\n\n  hideLoadingIndicator(indicator) {\n    if (document.body.contains(indicator)) {\n      document.body.removeChild(indicator);\n    }\n  },\n};\n\n// =======================\n// Application Initialization\n// =======================\nclass App {\n  constructor() {\n    this.init();\n  }\n\n  init() {\n    // Initialize core systems\n    ThemeManager.init();\n    IDEManager.init();\n\n    // Initialize modals\n    this.repositoryModal = new RepositoryModal();\n    this.editRepositoryModal = new EditRepositoryModal();\n    this.collectionModal = new CollectionModal();\n    this.editCollectionModal = new EditCollectionModal();\n\n    // Initialize UI manager with modals\n    UIManager.init({\n      onEditRepository: (repo) => this.editRepositoryModal.open(repo),\n      onEditCollection: (collection) =>\n        this.editCollectionModal.open(collection),\n    });\n\n    // Handle electron API data\n    this.bindElectronEvents();\n\n    console.log(\"👋 OpenMate application initialized successfully\");\n  }\n\n  bindElectronEvents() {\n    if (window.electronAPI && window.electronAPI.onReposData) {\n      window.electronAPI.onReposData((data) => {\n        const { repos = [], collections = [] } = data;\n        AppState.setRepos(repos);\n        AppState.setCollections(collections);\n        UIManager.updateDisplay();\n      });\n    }\n  }\n}\n\n// =======================\n// Initialize Application\n// =======================\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new App();\n});\n\n// Import styles\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNxQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5tYXRlLXVpLy4vc3JjL3JlbmRlcmVyLmpzPzg4YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFN0YXRlIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBBcHBTdGF0ZSA9IHtcbiAgcmVwb3M6IFtdLFxuICBjb2xsZWN0aW9uczogW10sXG5cbiAgc2V0UmVwb3MocmVwb3MpIHtcbiAgICB0aGlzLnJlcG9zID0gcmVwb3M7XG4gIH0sXG5cbiAgc2V0Q29sbGVjdGlvbnMoY29sbGVjdGlvbnMpIHtcbiAgICB0aGlzLmNvbGxlY3Rpb25zID0gY29sbGVjdGlvbnM7XG4gIH0sXG5cbiAgZ2V0RmlsdGVyZWRSZXBvcyhzZWFyY2hUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVySXRlbXModGhpcy5yZXBvcywgc2VhcmNoVGVybSk7XG4gIH0sXG5cbiAgZ2V0RmlsdGVyZWRDb2xsZWN0aW9ucyhzZWFyY2hUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVySXRlbXModGhpcy5jb2xsZWN0aW9ucywgc2VhcmNoVGVybSk7XG4gIH0sXG5cbiAgZmlsdGVySXRlbXMoaXRlbXMsIHNlYXJjaFRlcm0pIHtcbiAgICBpZiAoIXNlYXJjaFRlcm0pIHJldHVybiBpdGVtcztcbiAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgICAoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHxcbiAgICAgICAgKGl0ZW0ucGF0aCAmJiBpdGVtLnBhdGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSkgfHxcbiAgICAgICAgKGl0ZW0ucmVwb3MgJiYgaXRlbS5yZXBvcy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pKVxuICAgICk7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVXRpbGl0eSBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBVdGlscyA9IHtcbiAgZm9ybWF0UGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGggPyBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpIDogXCJcIjtcbiAgfSxcblxuICBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGVkRnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgZnVuYyguLi5hcmdzKTtcbiAgICAgIH07XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfTtcbiAgfSxcblxuICBjcmVhdGVFbGVtZW50KHRhZywgYXR0cmlidXRlcyA9IHt9LCBjaGlsZHJlbiA9IFtdKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NOYW1lXCIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFN0b3JhZ2UgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IFN0b3JhZ2UgPSB7XG4gIFRIRU1FX0tFWTogXCJvcGVubWF0ZS10aGVtZVwiLFxuICBJREVfS0VZOiBcIm9wZW5tYXRlLWlkZS1zZWxlY3RvclwiLFxuXG4gIGdldChrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU3RvcmFnZSBnZXQgZmFpbGVkOlwiLCBlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTdG9yYWdlIHNldCBmYWlsZWQ6XCIsIGUpO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUaGVtZSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgVGhlbWVNYW5hZ2VyID0ge1xuICBpbml0KCkge1xuICAgIHRoaXMudGhlbWVUb2dnbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRoZW1lLXRvZ2dsZVwiKTtcbiAgICB0aGlzLnRoZW1lSWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGhlbWUtaWNvblwiKTtcblxuICAgIHRoaXMubG9hZFRoZW1lKCk7XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH0sXG5cbiAgbG9hZFRoZW1lKCkge1xuICAgIGNvbnN0IHNhdmVkVGhlbWUgPSBTdG9yYWdlLmdldChTdG9yYWdlLlRIRU1FX0tFWSk7XG4gICAgY29uc3Qgc3lzdGVtUHJlZmVyc0RhcmsgPSB3aW5kb3cubWF0Y2hNZWRpYShcbiAgICAgIFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIGNvbnN0IHRoZW1lID0gc2F2ZWRUaGVtZSB8fCAoc3lzdGVtUHJlZmVyc0RhcmsgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG5cbiAgICB0aGlzLnNldFRoZW1lKHRoZW1lKTtcbiAgfSxcblxuICBzZXRUaGVtZSh0aGVtZSkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRoZW1lXCIsIHRoZW1lKTtcbiAgICB0aGlzLnRoZW1lSWNvbi50ZXh0Q29udGVudCA9IHRoZW1lID09PSBcImRhcmtcIiA/IFwi4piA77iPXCIgOiBcIvCfjJlcIjtcbiAgICBTdG9yYWdlLnNldChTdG9yYWdlLlRIRU1FX0tFWSwgdGhlbWUpO1xuICB9LFxuXG4gIHRvZ2dsZSgpIHtcbiAgICBjb25zdCBjdXJyZW50VGhlbWUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10aGVtZVwiKTtcbiAgICBjb25zdCBuZXdUaGVtZSA9IGN1cnJlbnRUaGVtZSA9PT0gXCJkYXJrXCIgPyBcImxpZ2h0XCIgOiBcImRhcmtcIjtcbiAgICB0aGlzLnNldFRoZW1lKG5ld1RoZW1lKTtcbiAgfSxcblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMudGhlbWVUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMudG9nZ2xlKCkpO1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIElERSBTZWxlY3RvciBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgSURFTWFuYWdlciA9IHtcbiAgaW5pdCgpIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZGUtc2VsZWN0b3JcIik7XG4gICAgdGhpcy5sb2FkUHJlZmVyZW5jZSgpO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9LFxuXG4gIGxvYWRQcmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IHNhdmVkSURFID0gU3RvcmFnZS5nZXQoU3RvcmFnZS5JREVfS0VZKTtcbiAgICBpZiAoc2F2ZWRJREUpIHtcbiAgICAgIHRoaXMuc2VsZWN0b3IudmFsdWUgPSBzYXZlZElERTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0ZWRJREUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IudmFsdWU7XG4gIH0sXG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkSURFID0gZS50YXJnZXQudmFsdWU7XG4gICAgICBpZiAoc2VsZWN0ZWRJREUpIHtcbiAgICAgICAgU3RvcmFnZS5zZXQoU3RvcmFnZS5JREVfS0VZLCBzZWxlY3RlZElERSk7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoYERlZmF1bHQgSURFIHNldCB0byAke3NlbGVjdGVkSURFfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE5vdGlmaWNhdGlvbiBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgTm90aWZpY2F0aW9uTWFuYWdlciA9IHtcbiAgc2hvdyhtZXNzYWdlLCB0eXBlID0gXCJpbmZvXCIsIGR1cmF0aW9uID0gMzAwMCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHtcbiAgICAgIHN1Y2Nlc3M6IFwiIzRDQUY1MFwiLFxuICAgICAgZXJyb3I6IFwiI0Y0NDMzNlwiLFxuICAgICAgaW5mbzogXCIjMjE5NkYzXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFV0aWxzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdHlsZTogYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGJvdHRvbTogMjBweDtcbiAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgIHBhZGRpbmc6IDEwcHggMjBweDtcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnNbdHlwZV19O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgei1pbmRleDogMTAwMDtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2U7XG4gICAgICBgLFxuICAgICAgfSxcbiAgICAgIFttZXNzYWdlXVxuICAgICk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbik7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG5vdGlmaWNhdGlvbi5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMobm90aWZpY2F0aW9uKSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICB9LCBkdXJhdGlvbik7XG4gIH0sXG5cbiAgc2hvd1N1Y2Nlc3MobWVzc2FnZSkge1xuICAgIHRoaXMuc2hvdyhtZXNzYWdlLCBcInN1Y2Nlc3NcIik7XG4gIH0sXG5cbiAgc2hvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnNob3cobWVzc2FnZSwgXCJlcnJvclwiKTtcbiAgfSxcblxuICBzaG93SW5mbyhtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KG1lc3NhZ2UsIFwiaW5mb1wiKTtcbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNb2RhbCBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgTW9kYWwge1xuICBjb25zdHJ1Y3Rvcihtb2RhbElkLCBmb3JtSWQsIG9wZW5CdG5JZCkge1xuICAgIHRoaXMubW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcbiAgICB0aGlzLmZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtSWQpO1xuICAgIHRoaXMub3BlbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wZW5CdG5JZCk7XG4gICAgdGhpcy5jbG9zZUJ0biA9IHRoaXMubW9kYWwucXVlcnlTZWxlY3RvcihcIi5jbG9zZVwiKTtcblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLm9wZW5CdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLm9wZW4oKSk7XG4gICAgdGhpcy5jbG9zZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2UoKSk7XG5cbiAgICAvLyBDbG9zZSBvbiBvdXRzaWRlIGNsaWNrXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLm1vZGFsKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NlIG9uIEVzY2FwZSBrZXlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLm1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICB0aGlzLm9uT3BlbigpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiO1xuICAgIHRoaXMuZm9ybT8ucmVzZXQoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID09PSBcImZsZXhcIjtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICAvLyBPdmVycmlkZSBpbiBzdWJjbGFzc2VzXG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIC8vIE92ZXJyaWRlIGluIHN1YmNsYXNzZXNcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUmVwb3NpdG9yeSBNb2RhbFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIFJlcG9zaXRvcnlNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJhZGQtcmVwby1tb2RhbFwiLCBcImFkZC1yZXBvLWZvcm1cIiwgXCJhZGQtcmVwby1idG5cIik7XG4gICAgdGhpcy5uYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcG8tbmFtZVwiKTtcbiAgICB0aGlzLnBhdGhJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwby1wYXRoXCIpO1xuICAgIHRoaXMuYnJvd3NlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJicm93c2UtcGF0aFwiKTtcblxuICAgIHRoaXMuYmluZFJlcG9zaXRvcnlFdmVudHMoKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICB0aGlzLm5hbWVJbnB1dC5mb2N1cygpO1xuICB9XG5cbiAgYmluZFJlcG9zaXRvcnlFdmVudHMoKSB7XG4gICAgdGhpcy5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKGUpID0+IHRoaXMuaGFuZGxlU3VibWl0KGUpKTtcbiAgICB0aGlzLmJyb3dzZUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5icm93c2VQYXRoKCkpO1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlU3VibWl0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lSW5wdXQudmFsdWUudHJpbSgpO1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGhJbnB1dC52YWx1ZS50cmltKCk7XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVJbnB1dHMobmFtZSwgcGF0aCkpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuYWRkUmVwb3NpdG9yeSh7IG5hbWUsIHBhdGggfSk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFwiUmVwb3NpdG9yeSBhZGRlZCBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgVUlNYW5hZ2VyLnJlZnJlc2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBhZGRpbmcgcmVwb3NpdG9yeTogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVJbnB1dHMobmFtZSwgcGF0aCkge1xuICAgIGlmICghbmFtZSB8fCAhcGF0aCkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2UgZmlsbCBpbiBhbGwgZmllbGRzXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGJyb3dzZVBhdGgoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhdGggPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkub3BlbkRpcmVjdG9yeURpYWxvZygpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoSW5wdXQudmFsdWUgPSBwYXRoO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIHNlbGVjdGluZyBkaXJlY3Rvcnk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRWRpdCBSZXBvc2l0b3J5IE1vZGFsXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgRWRpdFJlcG9zaXRvcnlNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJlZGl0LXJlcG8tbW9kYWxcIiwgXCJlZGl0LXJlcG8tZm9ybVwiKTtcbiAgICB0aGlzLm5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1yZXBvLW5hbWVcIik7XG4gICAgdGhpcy5wYXRoSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtcmVwby1wYXRoXCIpO1xuICAgIHRoaXMub3JpZ2luYWxOYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtb3JpZ2luYWwtbmFtZVwiKTtcbiAgICB0aGlzLmJyb3dzZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1icm93c2UtcGF0aFwiKTtcbiAgICB0aGlzLmNsb3NlQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlZGl0LXJlcG8tbW9kYWwgLmNsb3NlXCIpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBvcGVuKHJlcG8pIHtcbiAgICAvLyBTdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB0aGlzLm9yaWdpbmFsTmFtZUlucHV0LnZhbHVlID0gcmVwby5uYW1lO1xuXG4gICAgLy8gU2V0IGN1cnJlbnQgdmFsdWVzIChyZWFkLW9ubHkpXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LXJlcG8tbmFtZVwiKS50ZXh0Q29udGVudCA9IHJlcG8ubmFtZTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnJlbnQtcmVwby1wYXRoXCIpLnRleHRDb250ZW50ID0gcmVwby5wYXRoO1xuXG4gICAgLy8gQ2xlYXIgYW5kIHJlc2V0IGZvcm0gZmllbGRzXG4gICAgdGhpcy5uYW1lSW5wdXQudmFsdWUgPSByZXBvLm5hbWU7XG4gICAgdGhpcy5wYXRoSW5wdXQudmFsdWUgPSByZXBvLnBhdGg7XG4gICAgdGhpcy5uYW1lSW5wdXQucGxhY2Vob2xkZXIgPSBgQ3VycmVudDogJHtyZXBvLm5hbWV9YDtcbiAgICB0aGlzLnBhdGhJbnB1dC5wbGFjZWhvbGRlciA9IGBDdXJyZW50OiAke3JlcG8ucGF0aH1gO1xuXG4gICAgLy8gT3BlbiBtb2RhbCBhbmQgZm9jdXNcbiAgICBzdXBlci5vcGVuKCk7XG4gICAgdGhpcy5uYW1lSW5wdXQuZm9jdXMoKTtcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5mb3JtPy5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChlKSA9PiB0aGlzLmhhbmRsZVN1Ym1pdChlKSk7XG4gICAgdGhpcy5icm93c2VCdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmJyb3dzZVBhdGgoKSk7XG4gICAgdGhpcy5jbG9zZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IHRoaXMub3JpZ2luYWxOYW1lSW5wdXQudmFsdWU7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZUlucHV0LnZhbHVlLnRyaW0oKSB8fCBvcmlnaW5hbE5hbWU7IC8vIFVzZSBvcmlnaW5hbCBuYW1lIGlmIG5ldyBuYW1lIGlzIGVtcHR5XG4gICAgY29uc3QgcGF0aCA9XG4gICAgICB0aGlzLnBhdGhJbnB1dC52YWx1ZS50cmltKCkgfHxcbiAgICAgIHRoaXMucGF0aElucHV0LnBsYWNlaG9sZGVyLnJlcGxhY2UoXCJDdXJyZW50OiBcIiwgXCJcIik7IC8vIFVzZSBjdXJyZW50IHBhdGggaWYgZW1wdHlcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cyhuYW1lLCBwYXRoKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IHJlcG9zaXRvcmllcyBkYXRhXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuXG4gICAgICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgZXhwZWN0ZWQgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCAhZGF0YS5yZXBvcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcG9zaXRvcnkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiQ3VycmVudCByZXBvc2l0b3JpZXM6XCIsIGRhdGEucmVwb3MpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgIGNvbnNvbGUubG9nKFwiTG9va2luZyBmb3IgcmVwb3NpdG9yeSB3aXRoIG5hbWU6XCIsIG9yaWdpbmFsTmFtZSk7IC8vIERlYnVnIGxvZ1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVwb3NpdG9yeSBleGlzdHNcbiAgICAgIGlmICghZGF0YS5yZXBvc1tvcmlnaW5hbE5hbWVdKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZXBvc2l0b3J5IG5vdCBmb3VuZCBpbjpcIiwgZGF0YS5yZXBvcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcG9zaXRvcnkgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBuYW1lIGlzIGJlaW5nIGNoYW5nZWQgdG8gYW4gZXhpc3Rpbmcgb25lIChleGNlcHQgY3VycmVudCByZXBvKVxuICAgICAgaWYgKG5hbWUgIT09IG9yaWdpbmFsTmFtZSAmJiBkYXRhLnJlcG9zW25hbWVdKSB7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICAgIFwiQSByZXBvc2l0b3J5IHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSByZXBvc2l0b3JpZXNcbiAgICAgIGNvbnN0IHVwZGF0ZWRSZXBvcyA9IHsgLi4uZGF0YS5yZXBvcyB9O1xuXG4gICAgICAvLyBJZiBuYW1lIGNoYW5nZWQsIHJlbW92ZSBvbGQgZW50cnlcbiAgICAgIGlmIChuYW1lICE9PSBvcmlnaW5hbE5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRSZXBvc1tvcmlnaW5hbE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgb3IgYWRkIHRoZSByZXBvc2l0b3J5IHdpdGggbmV3IHZhbHVlcyBhbmQgdXBkYXRlZEF0IHRpbWVzdGFtcFxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgdXBkYXRlZFJlcG9zW25hbWVdID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICB1cGRhdGVkQXQ6IGRhdGEucmVwb3Nbb3JpZ2luYWxOYW1lXT8udXBkYXRlZEF0IHx8IG5vdyxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNhdmUgdGhlIHVwZGF0ZWQgcmVwb3NpdG9yaWVzIHVzaW5nIHRoZSBjb3JyZWN0IElQQyBtZXRob2RcbiAgICAgIGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS53cml0ZVJlcG9zRmlsZSh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHJlcG9zOiB1cGRhdGVkUmVwb3MsXG4gICAgICB9KTtcblxuICAgICAgLy8gUmVmcmVzaCBVSVxuICAgICAgVUlNYW5hZ2VyLnJlZnJlc2goKTtcblxuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhcIlJlcG9zaXRvcnkgdXBkYXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyByZXBvc2l0b3J5OlwiLCBlcnJvcik7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byB1cGRhdGUgcmVwb3NpdG9yeTogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVJbnB1dHMobmFtZSwgcGF0aCkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2UgZW50ZXIgYSByZXBvc2l0b3J5IG5hbWVcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGF0aCkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2Ugc2VsZWN0IGEgcmVwb3NpdG9yeSBwYXRoXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGJyb3dzZVBhdGgoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhdGggPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkub3BlbkRpcmVjdG9yeURpYWxvZygpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoSW5wdXQudmFsdWUgPSBwYXRoO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIHNlbGVjdGluZyBkaXJlY3Rvcnk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRWRpdCBDb2xsZWN0aW9uIE1vZGFsXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgRWRpdENvbGxlY3Rpb25Nb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJlZGl0LWNvbGxlY3Rpb24tbW9kYWxcIiwgXCJlZGl0LWNvbGxlY3Rpb24tZm9ybVwiKTtcbiAgICB0aGlzLm5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1jb2xsZWN0aW9uLW5hbWVcIik7XG4gICAgdGhpcy5vcmlnaW5hbE5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgXCJlZGl0LW9yaWdpbmFsLWNvbGxlY3Rpb24tbmFtZVwiXG4gICAgKTtcbiAgICB0aGlzLmN1cnJlbnROYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnJlbnQtY29sbGVjdGlvbi1uYW1lXCIpO1xuICAgIHRoaXMuY3VycmVudFJlcG9zRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnJlbnQtY29sbGVjdGlvbi1yZXBvc1wiKTtcbiAgICB0aGlzLnJlcG9zU2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0LXJlcG9zLXNlbGVjdGlvblwiKTtcbiAgICB0aGlzLmNsb3NlQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlZGl0LWNvbGxlY3Rpb24tbW9kYWwgLmNsb3NlXCIpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBhc3luYyBvcGVuKGNvbGxlY3Rpb24pIHtcbiAgICAvLyBTdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB0aGlzLm9yaWdpbmFsTmFtZUlucHV0LnZhbHVlID0gY29sbGVjdGlvbi5uYW1lO1xuXG4gICAgLy8gU2V0IGN1cnJlbnQgdmFsdWVzXG4gICAgdGhpcy5jdXJyZW50TmFtZUVsLnRleHRDb250ZW50ID0gY29sbGVjdGlvbi5uYW1lO1xuXG4gICAgLy8gSGFuZGxlIGJvdGggYXJyYXkgYW5kIHN0cmluZyBmb3JtYXRzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgY29uc3QgcmVwb0xpc3QgPSBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24ucmVwb3MpXG4gICAgICA/IGNvbGxlY3Rpb24ucmVwb3NcbiAgICAgIDogKGNvbGxlY3Rpb24ucmVwb3MgfHwgXCJcIilcbiAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcblxuICAgIHRoaXMuY3VycmVudFJlcG9zRWwudGV4dENvbnRlbnQgPSByZXBvTGlzdC5sZW5ndGhcbiAgICAgID8gcmVwb0xpc3Quam9pbihcIiwgXCIpXG4gICAgICA6IFwiTm8gcmVwb3NpdG9yaWVzXCI7XG4gICAgdGhpcy5uYW1lSW5wdXQudmFsdWUgPSBjb2xsZWN0aW9uLm5hbWU7XG4gICAgdGhpcy5uYW1lSW5wdXQucGxhY2Vob2xkZXIgPSBgQ3VycmVudDogJHtjb2xsZWN0aW9uLm5hbWV9YDtcblxuICAgIC8vIExvYWQgcmVwb3NpdG9yaWVzIHdpdGggY3VycmVudCBzZWxlY3Rpb25cbiAgICBhd2FpdCB0aGlzLmxvYWRSZXBvc2l0b3JpZXMocmVwb0xpc3QpO1xuXG4gICAgLy8gT3BlbiBtb2RhbCBhbmQgZm9jdXNcbiAgICBzdXBlci5vcGVuKCk7XG4gICAgdGhpcy5uYW1lSW5wdXQuZm9jdXMoKTtcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5mb3JtPy5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChlKSA9PiB0aGlzLmhhbmRsZVN1Ym1pdChlKSk7XG5cbiAgICB0aGlzLmNsb3NlQnRuPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRSZXBvc2l0b3JpZXMoc2VsZWN0ZWRSZXBvcyA9IFtdKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG4gICAgICB0aGlzLnJlbmRlclJlcG9zaXRvcnlTZWxlY3Rpb24oZGF0YS5yZXBvcyB8fCB7fSwgc2VsZWN0ZWRSZXBvcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3IgbG9hZGluZyByZXBvc2l0b3JpZXM6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPVxuICAgICAgICAnPGRpdiBjbGFzcz1cImVycm9yXCI+RXJyb3IgbG9hZGluZyByZXBvc2l0b3JpZXMuIFBsZWFzZSB0cnkgYWdhaW4uPC9kaXY+JztcbiAgICB9XG4gIH1cblxuICByZW5kZXJSZXBvc2l0b3J5U2VsZWN0aW9uKHJlcG9zLCBzZWxlY3RlZFJlcG9zID0gW10pIHtcbiAgICBpZiAoIXJlcG9zIHx8IE9iamVjdC5rZXlzKHJlcG9zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJsb2FkaW5nXCI+Tm8gcmVwb3NpdG9yaWVzIGZvdW5kLiBBZGQgcmVwb3NpdG9yaWVzIGZpcnN0LjwvZGl2Pic7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVwb3NMaXN0ID0gT2JqZWN0LmVudHJpZXMocmVwb3MpXG4gICAgICAuc29ydCgoW25hbWVBXSwgW25hbWVCXSkgPT4gbmFtZUEubG9jYWxlQ29tcGFyZShuYW1lQikpXG4gICAgICAubWFwKFxuICAgICAgICAoW25hbWUsIHJlcG9dKSA9PiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyZXBvLWNoZWNrYm94LWl0ZW1cIj5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJlZGl0LXJlcG8tJHtuYW1lfVwiIG5hbWU9XCJyZXBvc1wiIHZhbHVlPVwiJHtuYW1lfVwiIFxuICAgICAgICAgICAgICAgICAke3NlbGVjdGVkUmVwb3MuaW5jbHVkZXMobmFtZSkgPyBcImNoZWNrZWRcIiA6IFwiXCJ9PlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJlZGl0LXJlcG8tJHtuYW1lfVwiPlxuICAgICAgICAgICAgPHNwYW4+JHtuYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicmVwby1wYXRoXCI+JHtyZXBvLnBhdGh9PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYFxuICAgICAgKVxuICAgICAgLmpvaW4oXCJcIik7XG5cbiAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9IHJlcG9zTGlzdDtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVN1Ym1pdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gdGhpcy5vcmlnaW5hbE5hbWVJbnB1dC52YWx1ZTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lSW5wdXQudmFsdWUudHJpbSgpO1xuICAgIGNvbnN0IHNlbGVjdGVkUmVwb3MgPSB0aGlzLmdldFNlbGVjdGVkUmVwb3NpdG9yaWVzKCk7XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVJbnB1dHMobmFtZSwgc2VsZWN0ZWRSZXBvcykpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuXG4gICAgICAvLyBDaGVjayBpZiBuYW1lIGlzIGJlaW5nIGNoYW5nZWQgdG8gYW4gZXhpc3Rpbmcgb25lIChleGNlcHQgY3VycmVudCBjb2xsZWN0aW9uKVxuICAgICAgaWYgKG5hbWUgIT09IG9yaWdpbmFsTmFtZSAmJiBkYXRhLmNvbGxlY3Rpb25zICYmIGRhdGEuY29sbGVjdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgICAgXCJBIGNvbGxlY3Rpb24gd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHNcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb25zXG4gICAgICBjb25zdCB1cGRhdGVkQ29sbGVjdGlvbnMgPSB7IC4uLmRhdGEuY29sbGVjdGlvbnMgfTtcblxuICAgICAgLy8gUmVtb3ZlIG9sZCBlbnRyeSBpZiBuYW1lIGNoYW5nZWRcbiAgICAgIGlmIChuYW1lICE9PSBvcmlnaW5hbE5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRDb2xsZWN0aW9uc1tvcmlnaW5hbE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgb3IgYWRkIHRoZSBjb2xsZWN0aW9uIHdpdGggbmV3IHZhbHVlc1xuICAgICAgdXBkYXRlZENvbGxlY3Rpb25zW25hbWVdID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICByZXBvczogc2VsZWN0ZWRSZXBvcywgLy8gU2F2ZSBhcyBhcnJheVxuICAgICAgICB1cGRhdGVkQXQ6XG4gICAgICAgICAgdXBkYXRlZENvbGxlY3Rpb25zW29yaWdpbmFsTmFtZV0/LnVwZGF0ZWRBdCB8fFxuICAgICAgICAgIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNhdmUgdGhlIHVwZGF0ZWQgY29sbGVjdGlvbnNcbiAgICAgIGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS53cml0ZVJlcG9zRmlsZSh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGNvbGxlY3Rpb25zOiB1cGRhdGVkQ29sbGVjdGlvbnMsXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhcIkNvbGxlY3Rpb24gdXBkYXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICBVSU1hbmFnZXIucmVmcmVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgY29sbGVjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gdXBkYXRlIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGdldFNlbGVjdGVkUmVwb3NpdG9yaWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKFxuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl06Y2hlY2tlZCcpXG4gICAgKS5tYXAoKGNoZWNrYm94KSA9PiBjaGVja2JveC52YWx1ZSk7XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0cyhuYW1lLCBzZWxlY3RlZFJlcG9zKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBlbnRlciBhIGNvbGxlY3Rpb24gbmFtZVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRSZXBvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgcmVwb3NpdG9yeVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ29sbGVjdGlvbiBNb2RhbFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIENvbGxlY3Rpb25Nb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJhZGQtY29sbGVjdGlvbi1tb2RhbFwiLCBcImFkZC1jb2xsZWN0aW9uLWZvcm1cIiwgXCJhZGQtY29sbGVjdGlvbi1idG5cIik7XG4gICAgdGhpcy5uYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbGxlY3Rpb24tbmFtZVwiKTtcbiAgICB0aGlzLnJlcG9zU2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXBvcy1zZWxlY3Rpb25cIik7XG5cbiAgICB0aGlzLmJpbmRDb2xsZWN0aW9uRXZlbnRzKCk7XG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgdGhpcy5uYW1lSW5wdXQuZm9jdXMoKTtcbiAgICBhd2FpdCB0aGlzLmxvYWRSZXBvc2l0b3JpZXMoKTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPVxuICAgICAgJzxkaXYgY2xhc3M9XCJsb2FkaW5nXCI+TG9hZGluZyByZXBvc2l0b3JpZXMuLi48L2Rpdj4nO1xuICB9XG5cbiAgYmluZENvbGxlY3Rpb25FdmVudHMoKSB7XG4gICAgdGhpcy5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKGUpID0+IHRoaXMuaGFuZGxlU3VibWl0KGUpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRSZXBvc2l0b3JpZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG4gICAgICB0aGlzLnJlbmRlclJlcG9zaXRvcnlTZWxlY3Rpb24oZGF0YS5yZXBvcyB8fCB7fSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3IgbG9hZGluZyByZXBvc2l0b3JpZXM6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPVxuICAgICAgICAnPGRpdiBjbGFzcz1cImVycm9yXCI+RXJyb3IgbG9hZGluZyByZXBvc2l0b3JpZXMuIFBsZWFzZSB0cnkgYWdhaW4uPC9kaXY+JztcbiAgICB9XG4gIH1cblxuICByZW5kZXJSZXBvc2l0b3J5U2VsZWN0aW9uKHJlcG9zKSB7XG4gICAgaWYgKCFyZXBvcyB8fCBPYmplY3Qua2V5cyhyZXBvcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9XG4gICAgICAgICc8ZGl2IGNsYXNzPVwibG9hZGluZ1wiPk5vIHJlcG9zaXRvcmllcyBmb3VuZC4gQWRkIHJlcG9zaXRvcmllcyBmaXJzdC48L2Rpdj4nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcG9zTGlzdCA9IE9iamVjdC5lbnRyaWVzKHJlcG9zKVxuICAgICAgLnNvcnQoKFtuYW1lQV0sIFtuYW1lQl0pID0+IG5hbWVBLmxvY2FsZUNvbXBhcmUobmFtZUIpKVxuICAgICAgLm1hcChcbiAgICAgICAgKFtuYW1lLCByZXBvXSkgPT4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwicmVwby1jaGVja2JveC1pdGVtXCI+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwicmVwby0ke25hbWV9XCIgbmFtZT1cInJlcG9zXCIgdmFsdWU9XCIke25hbWV9XCI+XG4gICAgICAgICAgPGxhYmVsIGZvcj1cInJlcG8tJHtuYW1lfVwiPlxuICAgICAgICAgICAgPHNwYW4+JHtuYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicmVwby1wYXRoXCI+JHtyZXBvLnBhdGh9PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYFxuICAgICAgKVxuICAgICAgLmpvaW4oXCJcIik7XG5cbiAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9IHJlcG9zTGlzdDtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVN1Ym1pdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBjb25zdCBzZWxlY3RlZFJlcG9zID0gdGhpcy5nZXRTZWxlY3RlZFJlcG9zaXRvcmllcygpO1xuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5wdXRzKG5hbWUsIHNlbGVjdGVkUmVwb3MpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zYXZlQ29sbGVjdGlvbihuYW1lLCBzZWxlY3RlZFJlcG9zKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXCJDb2xsZWN0aW9uIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcbiAgICAgIFVJTWFuYWdlci5yZWZyZXNoKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3IgY3JlYXRpbmcgY29sbGVjdGlvbjogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2VsZWN0ZWRSZXBvc2l0b3JpZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXTpjaGVja2VkJylcbiAgICApLm1hcCgoY2hlY2tib3gpID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgfVxuXG4gIHZhbGlkYXRlSW5wdXRzKG5hbWUsIHNlbGVjdGVkUmVwb3MpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIGVudGVyIGEgY29sbGVjdGlvbiBuYW1lXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZFJlcG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSByZXBvc2l0b3J5XCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgc2F2ZUNvbGxlY3Rpb24obmFtZSwgc2VsZWN0ZWRSZXBvcykge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG5cbiAgICBpZiAoZGF0YS5jb2xsZWN0aW9ucyAmJiBkYXRhLmNvbGxlY3Rpb25zW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbGxlY3Rpb24gd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhLmNvbGxlY3Rpb25zKSBkYXRhLmNvbGxlY3Rpb25zID0ge307XG4gICAgZGF0YS5jb2xsZWN0aW9uc1tuYW1lXSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICByZXBvczogc2VsZWN0ZWRSZXBvcyxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkud3JpdGVSZXBvc0ZpbGUoZGF0YSk7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFVJIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBVSU1hbmFnZXIgPSB7XG4gIGluaXQoY2FsbGJhY2tzID0ge30pIHtcbiAgICB0aGlzLnNlYXJjaElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2gtaW5wdXRcIik7XG4gICAgdGhpcy5yZWZyZXNoQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZWZyZXNoLWJ0blwiKTtcblxuICAgIC8vIFN0b3JlIGNhbGxiYWNrc1xuICAgIHRoaXMuaGFuZGxlRWRpdFJlcG9zaXRvcnkgPSBjYWxsYmFja3Mub25FZGl0UmVwb3NpdG9yeSB8fCAoKCkgPT4ge30pO1xuICAgIHRoaXMuaGFuZGxlRWRpdENvbGxlY3Rpb24gPSBjYWxsYmFja3Mub25FZGl0Q29sbGVjdGlvbiB8fCAoKCkgPT4ge30pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBlZGl0IGNvbGxlY3Rpb24gbW9kYWwgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsKSB7XG4gICAgICB0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwgPSBuZXcgRWRpdENvbGxlY3Rpb25Nb2RhbCgpO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9LFxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgLy8gRGVib3VuY2Ugc2VhcmNoIHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbiAgICBjb25zdCBkZWJvdW5jZWRVcGRhdGUgPSBVdGlscy5kZWJvdW5jZSgoKSA9PiB0aGlzLnVwZGF0ZURpc3BsYXkoKSwgMzAwKTtcbiAgICB0aGlzLnNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBkZWJvdW5jZWRVcGRhdGUpO1xuICAgIHRoaXMucmVmcmVzaEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICB9LFxuXG4gIGFzeW5jIHJlZnJlc2goKSB7XG4gICAgdGhpcy5zaG93UmVmcmVzaEFuaW1hdGlvbigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG4gICAgICB0aGlzLnByb2Nlc3NEYXRhKGRhdGEpO1xuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKGBFcnJvciByZWZyZXNoaW5nIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5oaWRlUmVmcmVzaEFuaW1hdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICBwcm9jZXNzRGF0YShkYXRhKSB7XG4gICAgLy8gUHJvY2VzcyByZXBvc2l0b3JpZXNcbiAgICBpZiAoZGF0YS5yZXBvcykge1xuICAgICAgY29uc3QgcmVwb3MgPSBPYmplY3QuZW50cmllcyhkYXRhLnJlcG9zKS5tYXAoKFtuYW1lLCByZXBvXSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGF0aDogcmVwby5wYXRoLFxuICAgICAgICB1cGRhdGVkQXQ6IHJlcG8udXBkYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pKTtcbiAgICAgIEFwcFN0YXRlLnNldFJlcG9zKHJlcG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQXBwU3RhdGUuc2V0UmVwb3MoW10pO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgY29sbGVjdGlvbnNcbiAgICBpZiAoZGF0YS5jb2xsZWN0aW9ucykge1xuICAgICAgY29uc3QgY29sbGVjdGlvbnMgPSBPYmplY3QudmFsdWVzKGRhdGEuY29sbGVjdGlvbnMpLm1hcCgoY29sbGVjdGlvbikgPT4gKHtcbiAgICAgICAgbmFtZTogY29sbGVjdGlvbi5uYW1lLFxuICAgICAgICByZXBvczogQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uLnJlcG9zKVxuICAgICAgICAgID8gY29sbGVjdGlvbi5yZXBvcy5qb2luKFwiLCBcIilcbiAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIHVwZGF0ZWRBdDogY29sbGVjdGlvbi51cGRhdGVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSkpO1xuICAgICAgQXBwU3RhdGUuc2V0Q29sbGVjdGlvbnMoY29sbGVjdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBBcHBTdGF0ZS5zZXRDb2xsZWN0aW9ucyhbXSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgY29uc3Qgc2VhcmNoVGVybSA9IHRoaXMuc2VhcmNoSW5wdXQudmFsdWUudHJpbSgpO1xuICAgIHRoaXMudXBkYXRlUmVwb3NpdG9yaWVzVGFibGUoQXBwU3RhdGUuZ2V0RmlsdGVyZWRSZXBvcyhzZWFyY2hUZXJtKSk7XG4gICAgdGhpcy51cGRhdGVDb2xsZWN0aW9uc1RhYmxlKEFwcFN0YXRlLmdldEZpbHRlcmVkQ29sbGVjdGlvbnMoc2VhcmNoVGVybSkpO1xuICB9LFxuXG4gIHVwZGF0ZVJlcG9zaXRvcmllc1RhYmxlKHJlcG9zKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXBvcy1saXN0XCIpO1xuICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXBvcy10YWJsZVwiKTtcbiAgICBjb25zdCBsb2FkaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2FkaW5nLXJlcG9zXCIpO1xuXG4gICAgaWYgKHJlcG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9hZGluZy50ZXh0Q29udGVudCA9IFwiTm8gbWF0Y2hpbmcgcmVwb3NpdG9yaWVzIGZvdW5kLlwiO1xuICAgICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGFibGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHRhYmxlLnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlXCI7XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gcmVwb3NcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKVxuICAgICAgLm1hcCgocmVwbykgPT4gdGhpcy5jcmVhdGVSZXBvc2l0b3J5Um93KHJlcG8pKVxuICAgICAgLmpvaW4oXCJcIik7XG5cbiAgICB0aGlzLmJpbmRSZXBvc2l0b3J5RXZlbnRzKCk7XG4gIH0sXG5cbiAgY3JlYXRlUmVwb3NpdG9yeVJvdyhyZXBvKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDx0ciBkYXRhLXBhdGg9XCIke1V0aWxzLmZvcm1hdFBhdGgocmVwby5wYXRoKX1cIiBjbGFzcz1cImNsaWNrYWJsZS1yZXBvLXJvd1wiPlxuICAgICAgICA8dGQ+PHN0cm9uZz4ke3JlcG8ubmFtZX08L3N0cm9uZz48L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJwYXRoXCI+JHtVdGlscy5mb3JtYXRQYXRoKHJlcG8ucGF0aCl9PC90ZD5cbiAgICAgICAgPHRkIGNsYXNzPVwiYWN0aW9uc1wiPlxuICAgICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBnYXA6IDVweFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImVkaXQtYnRuXCIgZGF0YS1uYW1lPVwiJHtyZXBvLm5hbWV9XCIgZGF0YS1wYXRoPVwiJHtVdGlscy5mb3JtYXRQYXRoKHJlcG8ucGF0aCl9XCIgZGF0YS10eXBlPVwicmVwb1wiIHRpdGxlPVwiRWRpdCByZXBvc2l0b3J5XCI+4pyP77iPPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZGVsZXRlLWJ0blwiIGRhdGEtbmFtZT1cIiR7cmVwby5uYW1lfVwiIGRhdGEtdHlwZT1cInJlcG9cIiB0aXRsZT1cIkRlbGV0ZSByZXBvc2l0b3J5XCI+8J+Xke+4jzwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3RkPlxuICAgICAgPC90cj5cbiAgICBgO1xuICB9LFxuXG4gIGJpbmRSZXBvc2l0b3J5RXZlbnRzKCkge1xuICAgIC8vIEJpbmQgY2xpY2sgZXZlbnRzIGZvciBvcGVuaW5nIHJlcG9zaXRvcmllc1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2xpY2thYmxlLXJlcG8tcm93XCIpLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgcm93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4gdGhpcy5oYW5kbGVSZXBvc2l0b3J5Q2xpY2soZSwgcm93KSk7XG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGVkaXQgZXZlbnRzXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmVkaXQtYnRuW2RhdGEtdHlwZT1cInJlcG9cIl0nKS5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGJ0bi5kYXRhc2V0Lm5hbWU7XG4gICAgICAgIGNvbnN0IHBhdGggPSBidG4uZGF0YXNldC5wYXRoO1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVFZGl0UmVwb3NpdG9yeSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRWRpdFJlcG9zaXRvcnkoeyBuYW1lLCBwYXRoIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgZGVsZXRlIGV2ZW50c1xuICAgIGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLmRlbGV0ZS1idG5bZGF0YS10eXBlPVwicmVwb1wiXScpXG4gICAgICAuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+XG4gICAgICAgICAgdGhpcy5oYW5kbGVSZXBvc2l0b3J5RGVsZXRlKGUsIGJ0bilcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9LFxuXG4gIGFzeW5jIGhhbmRsZVJlcG9zaXRvcnlDbGljayhlLCByb3cpIHtcbiAgICBpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJCVVRUT05cIikgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRJREUgPSBJREVNYW5hZ2VyLmdldFNlbGVjdGVkSURFKCk7XG4gICAgaWYgKCFzZWxlY3RlZElERSkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2Ugc2VsZWN0IGFuIElERSBmaXJzdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXBvUGF0aCA9IHJvdy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhdGhcIik7XG4gICAgaWYgKCFyZXBvUGF0aCkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5vcGVuSW5JREUoe1xuICAgICAgICBuYW1lOiByb3cuZ2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIpLFxuICAgICAgICBwYXRoOiByZXBvUGF0aCxcbiAgICAgICAgaWRlOiBzZWxlY3RlZElERSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IgfHwgXCJGYWlsZWQgdG8gb3BlbiBpbiBJREVcIik7XG4gICAgICB9XG5cbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXG4gICAgICAgIGBTdWNjZXNzZnVsbHkgb3BlbmVkICR7cmVwb1BhdGh9IGluICR7c2VsZWN0ZWRJREV9YFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoYEVycm9yIG9wZW5pbmcgSURFOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIGhhbmRsZVJlcG9zaXRvcnlEZWxldGUoZSwgYnRuKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IG5hbWUgPSBidG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIpO1xuICAgIC8vIGlmICghY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSByZXBvc2l0b3J5IFwiJHtuYW1lfVwiP2ApKVxuICAgIC8vICAgcmV0dXJuO1xuXG4gICAgY29uc3QgbG9hZGluZ0VsID0gdGhpcy5zaG93TG9hZGluZ0luZGljYXRvcihcIkRlbGV0aW5nLi4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5kZWxldGVSZXBvKG5hbWUpO1xuXG4gICAgICBpZiAocmVzdWx0Py5zdWNjZXNzKSB7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Py5lcnJvciB8fCBcIlVua25vd24gZXJyb3JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKGBFcnJvciBkZWxldGluZyAke25hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmdJbmRpY2F0b3IobG9hZGluZ0VsKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlQ29sbGVjdGlvbnNUYWJsZShjb2xsZWN0aW9ucykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29sbGVjdGlvbnMtbGlzdFwiKTtcbiAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29sbGVjdGlvbnMtdGFibGVcIik7XG4gICAgY29uc3QgbG9hZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1jb2xsZWN0aW9uc1wiKTtcblxuICAgIGlmIChjb2xsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvYWRpbmcudGV4dENvbnRlbnQgPSBcIk5vIG1hdGNoaW5nIGNvbGxlY3Rpb25zIGZvdW5kLlwiO1xuICAgICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGFibGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHRhYmxlLnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlXCI7XG5cbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gY29sbGVjdGlvbnNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKVxuICAgICAgLm1hcCgoY29sbGVjdGlvbikgPT4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uUm93KGNvbGxlY3Rpb24pKVxuICAgICAgLmpvaW4oXCJcIik7XG5cbiAgICB0aGlzLmJpbmRDb2xsZWN0aW9uRXZlbnRzKCk7XG4gIH0sXG5cbiAgY3JlYXRlQ29sbGVjdGlvblJvdyhjb2xsZWN0aW9uKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbkRhdGEgPSBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKTtcbiAgICByZXR1cm4gYFxuICAgICAgPHRyIGNsYXNzPVwiY2xpY2thYmxlLWNvbGxlY3Rpb24tcm93XCIgZGF0YS1jb2xsZWN0aW9uPVwiJHtjb2xsZWN0aW9uRGF0YX1cIj5cbiAgICAgICAgPHRkPjxzdHJvbmc+JHtjb2xsZWN0aW9uLm5hbWV9PC9zdHJvbmc+PC90ZD5cbiAgICAgICAgPHRkPiR7Y29sbGVjdGlvbi5yZXBvc308L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJhY3Rpb25zXCI+XG4gICAgICAgICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGdhcDogNXB4XCI+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZWRpdC1idG5cIiBkYXRhLW5hbWU9XCIke2NvbGxlY3Rpb24ubmFtZX1cIiBkYXRhLXR5cGU9XCJjb2xsZWN0aW9uXCIgdGl0bGU9XCJFZGl0IGNvbGxlY3Rpb25cIj7inI/vuI88L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkZWxldGUtYnRuXCIgZGF0YS1uYW1lPVwiJHtjb2xsZWN0aW9uLm5hbWV9XCIgZGF0YS10eXBlPVwiY29sbGVjdGlvblwiIHRpdGxlPVwiRGVsZXRlIGNvbGxlY3Rpb25cIj7wn5eR77iPPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvdGQ+XG4gICAgICA8L3RyPlxuICAgIGA7XG4gIH0sXG5cbiAgYmluZENvbGxlY3Rpb25FdmVudHMoKSB7XG4gICAgLy8gQmluZCBjbGljayBldmVudHMgZm9yIG9wZW5pbmcgY29sbGVjdGlvbnNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNsaWNrYWJsZS1jb2xsZWN0aW9uLXJvd1wiKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMuaGFuZGxlQ29sbGVjdGlvbkNsaWNrKGUsIHJvdykpO1xuICAgIH0pO1xuXG4gICAgLy8gQmluZCBlZGl0IGV2ZW50c1xuICAgIGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLmVkaXQtYnRuW2RhdGEtdHlwZT1cImNvbGxlY3Rpb25cIl0nKVxuICAgICAgLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uRGF0YSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICBidG5cbiAgICAgICAgICAgICAgLmNsb3Nlc3QoXCJ0clwiKVxuICAgICAgICAgICAgICAuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xsZWN0aW9uXCIpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbC5vcGVuKGNvbGxlY3Rpb25EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAvLyBCaW5kIGRlbGV0ZSBldmVudHNcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZWxldGUtYnRuW2RhdGEtdHlwZT1cImNvbGxlY3Rpb25cIl0nKVxuICAgICAgLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PlxuICAgICAgICAgIHRoaXMuaGFuZGxlQ29sbGVjdGlvbkRlbGV0ZShlLCBidG4pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgfSxcblxuICBhc3luYyBoYW5kbGVDb2xsZWN0aW9uQ2xpY2soZSwgcm93KSB7XG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQlVUVE9OXCIpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uID0gSlNPTi5wYXJzZShyb3cuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xsZWN0aW9uXCIpKTtcbiAgICAgIGNvbnN0IHJlcG9zRGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcblxuICAgICAgY29uc3QgcmVwb3MgPSBjb2xsZWN0aW9uLnJlcG9zLnNwbGl0KFwiLFwiKS5tYXAoKHJlcG8pID0+IHtcbiAgICAgICAgY29uc3QgW25hbWUsIHBhdGgsIGlkZV0gPSByZXBvXG4gICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgIC5zcGxpdChcInxcIilcbiAgICAgICAgICAubWFwKChzKSA9PiBzLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIHBhdGgsIGlkZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9wZW4gYWxsIHJlcG9zaXRvcmllcyBpbiBwYXJhbGxlbFxuICAgICAgY29uc3QgcHJvbWlzZXMgPSByZXBvcy5tYXAoYXN5bmMgKHJlcG8pID0+IHtcbiAgICAgICAgY29uc3QgcmVwb0RhdGEgPSByZXBvc0RhdGEucmVwb3NbcmVwby5uYW1lXTtcblxuICAgICAgICBpZiAoIXJlcG9EYXRhKSB7XG4gICAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgICAgICBgJHtyZXBvLm5hbWV9OiBOb3QgZm91bmQgaW4gcmVwb3NpdG9yaWVzYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWRlID0gcmVwby5pZGUgfHwgSURFTWFuYWdlci5nZXRTZWxlY3RlZElERSgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLm9wZW5JbklERSh7XG4gICAgICAgICAgICBuYW1lOiByZXBvLm5hbWUsXG4gICAgICAgICAgICBwYXRoOiByZXBvRGF0YS5wYXRoLFxuICAgICAgICAgICAgaWRlOiBpZGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIG9wZW4gJHtyZXBvLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhgU3VjY2Vzc2Z1bGx5IG9wZW5lZCAke2NvbGxlY3Rpb24ubmFtZX1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICBhc3luYyBoYW5kbGVDb2xsZWN0aW9uRGVsZXRlKGUsIGJ0bikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBuYW1lID0gYnRuLmdldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiKTtcbiAgICAvLyBpZiAoIWNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgY29sbGVjdGlvbiBcIiR7bmFtZX1cIj9gKSlcbiAgICAvLyAgIHJldHVybjtcblxuICAgIGNvbnN0IGxvYWRpbmdFbCA9IHRoaXMuc2hvd0xvYWRpbmdJbmRpY2F0b3IoXCJEZWxldGluZy4uLlwiKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZGVsZXRlQ29sbGVjdGlvbihuYW1lKTtcblxuICAgICAgaWYgKHJlc3VsdD8uc3VjY2Vzcykge1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKGBTdWNjZXNzZnVsbHkgZGVsZXRlZCAke25hbWV9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdD8uZXJyb3IgfHwgXCJVbmtub3duIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihgRXJyb3IgZGVsZXRpbmcgJHtuYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmhpZGVMb2FkaW5nSW5kaWNhdG9yKGxvYWRpbmdFbCk7XG4gICAgfVxuICB9LFxuXG4gIHNob3dSZWZyZXNoQW5pbWF0aW9uKCkge1xuICAgIHRoaXMucmVmcmVzaEJ0bi5jbGFzc0xpc3QuYWRkKFwicm90YXRpbmdcIik7XG4gIH0sXG5cbiAgaGlkZVJlZnJlc2hBbmltYXRpb24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlZnJlc2hCdG4uY2xhc3NMaXN0LnJlbW92ZShcInJvdGF0aW5nXCIpO1xuICAgIH0sIDEwMDApO1xuICB9LFxuXG4gIHNob3dMb2FkaW5nSW5kaWNhdG9yKHRleHQpIHtcbiAgICBjb25zdCBpbmRpY2F0b3IgPSBVdGlscy5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgICBwYWRkaW5nOiAxMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuNyk7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgICAgYCxcbiAgICAgIH0sXG4gICAgICBbdGV4dF1cbiAgICApO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbmRpY2F0b3IpO1xuICAgIHJldHVybiBpbmRpY2F0b3I7XG4gIH0sXG5cbiAgaGlkZUxvYWRpbmdJbmRpY2F0b3IoaW5kaWNhdG9yKSB7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoaW5kaWNhdG9yKSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbmRpY2F0b3IpO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBcHBsaWNhdGlvbiBJbml0aWFsaXphdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIEFwcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBJbml0aWFsaXplIGNvcmUgc3lzdGVtc1xuICAgIFRoZW1lTWFuYWdlci5pbml0KCk7XG4gICAgSURFTWFuYWdlci5pbml0KCk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1vZGFsc1xuICAgIHRoaXMucmVwb3NpdG9yeU1vZGFsID0gbmV3IFJlcG9zaXRvcnlNb2RhbCgpO1xuICAgIHRoaXMuZWRpdFJlcG9zaXRvcnlNb2RhbCA9IG5ldyBFZGl0UmVwb3NpdG9yeU1vZGFsKCk7XG4gICAgdGhpcy5jb2xsZWN0aW9uTW9kYWwgPSBuZXcgQ29sbGVjdGlvbk1vZGFsKCk7XG4gICAgdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsID0gbmV3IEVkaXRDb2xsZWN0aW9uTW9kYWwoKTtcblxuICAgIC8vIEluaXRpYWxpemUgVUkgbWFuYWdlciB3aXRoIG1vZGFsc1xuICAgIFVJTWFuYWdlci5pbml0KHtcbiAgICAgIG9uRWRpdFJlcG9zaXRvcnk6IChyZXBvKSA9PiB0aGlzLmVkaXRSZXBvc2l0b3J5TW9kYWwub3BlbihyZXBvKSxcbiAgICAgIG9uRWRpdENvbGxlY3Rpb246IChjb2xsZWN0aW9uKSA9PlxuICAgICAgICB0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwub3Blbihjb2xsZWN0aW9uKSxcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlbGVjdHJvbiBBUEkgZGF0YVxuICAgIHRoaXMuYmluZEVsZWN0cm9uRXZlbnRzKCk7XG5cbiAgICBjb25zb2xlLmxvZyhcIvCfkYsgT3Blbk1hdGUgYXBwbGljYXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICB9XG5cbiAgYmluZEVsZWN0cm9uRXZlbnRzKCkge1xuICAgIGlmICh3aW5kb3cuZWxlY3Ryb25BUEkgJiYgd2luZG93LmVsZWN0cm9uQVBJLm9uUmVwb3NEYXRhKSB7XG4gICAgICB3aW5kb3cuZWxlY3Ryb25BUEkub25SZXBvc0RhdGEoKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXBvcyA9IFtdLCBjb2xsZWN0aW9ucyA9IFtdIH0gPSBkYXRhO1xuICAgICAgICBBcHBTdGF0ZS5zZXRSZXBvcyhyZXBvcyk7XG4gICAgICAgIEFwcFN0YXRlLnNldENvbGxlY3Rpb25zKGNvbGxlY3Rpb25zKTtcbiAgICAgICAgVUlNYW5hZ2VyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSW5pdGlhbGl6ZSBBcHBsaWNhdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgbmV3IEFwcCgpO1xufSk7XG5cbi8vIEltcG9ydCBzdHlsZXNcbmltcG9ydCBcIi4vaW5kZXguY3NzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/renderer.js\n\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("2e5d0e6d4bf3cc7245a7")
/******/ })();
/******/ 
/******/ }
);