"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateopenmate_ui"]("main_window",{

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n// =======================\n// State Management\n// =======================\nconst AppState = {\n  repos: [],\n  collections: [],\n\n  setRepos(repos) {\n    this.repos = repos;\n  },\n\n  setCollections(collections) {\n    this.collections = collections;\n  },\n\n  getFilteredRepos(searchTerm) {\n    return this.filterItems(this.repos, searchTerm);\n  },\n\n  getFilteredCollections(searchTerm) {\n    return this.filterItems(this.collections, searchTerm);\n  },\n\n  filterItems(items, searchTerm) {\n    if (!searchTerm) return items;\n    const term = searchTerm.toLowerCase();\n    return items.filter(\n      (item) =>\n        item.name.toLowerCase().includes(term) ||\n        (item.path && item.path.toLowerCase().includes(term)) ||\n        (item.repos && item.repos.toLowerCase().includes(term))\n    );\n  },\n};\n\n// =======================\n// Utility Functions\n// =======================\nconst Utils = {\n  formatPath(path) {\n    return path ? path.replace(/\\\\/g, \"/\") : \"\";\n  },\n\n  debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  },\n\n  createElement(tag, attributes = {}, children = []) {\n    const element = document.createElement(tag);\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (key === \"className\") {\n        element.className = value;\n      } else {\n        element.setAttribute(key, value);\n      }\n    });\n    children.forEach((child) => {\n      if (typeof child === \"string\") {\n        element.appendChild(document.createTextNode(child));\n      } else {\n        element.appendChild(child);\n      }\n    });\n    return element;\n  },\n};\n\n// =======================\n// Storage Management\n// =======================\nconst Storage = {\n  THEME_KEY: \"openmate-theme\",\n  IDE_KEY: \"openmate-ide-selector\",\n\n  get(key) {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      console.warn(\"Storage get failed:\", e);\n      return null;\n    }\n  },\n\n  set(key, value) {\n    try {\n      localStorage.setItem(key, value);\n    } catch (e) {\n      console.warn(\"Storage set failed:\", e);\n    }\n  },\n};\n\n// =======================\n// Theme Management\n// =======================\nconst ThemeManager = {\n  init() {\n    this.themeToggle = document.getElementById(\"theme-toggle\");\n    this.themeIcon = document.querySelector(\".theme-icon\");\n\n    this.loadTheme();\n    this.bindEvents();\n  },\n\n  loadTheme() {\n    const savedTheme = Storage.get(Storage.THEME_KEY);\n    const systemPrefersDark = window.matchMedia(\n      \"(prefers-color-scheme: dark)\"\n    ).matches;\n    const theme = savedTheme || (systemPrefersDark ? \"dark\" : \"light\");\n\n    this.setTheme(theme);\n  },\n\n  setTheme(theme) {\n    document.documentElement.setAttribute(\"data-theme\", theme);\n    this.themeIcon.textContent = theme === \"dark\" ? \"☀️\" : \"🌙\";\n    Storage.set(Storage.THEME_KEY, theme);\n  },\n\n  toggle() {\n    const currentTheme = document.documentElement.getAttribute(\"data-theme\");\n    const newTheme = currentTheme === \"dark\" ? \"light\" : \"dark\";\n    this.setTheme(newTheme);\n  },\n\n  bindEvents() {\n    this.themeToggle.addEventListener(\"click\", () => this.toggle());\n  },\n};\n\n// =======================\n// IDE Selector Management\n// =======================\nconst IDEManager = {\n  init() {\n    this.selector = document.getElementById(\"ide-selector\");\n    this.loadPreference();\n    this.bindEvents();\n  },\n\n  loadPreference() {\n    const savedIDE = Storage.get(Storage.IDE_KEY);\n    if (savedIDE) {\n      this.selector.value = savedIDE;\n    }\n  },\n\n  getSelectedIDE() {\n    return this.selector.value;\n  },\n\n  bindEvents() {\n    this.selector.addEventListener(\"change\", (e) => {\n      const selectedIDE = e.target.value;\n      if (selectedIDE) {\n        Storage.set(Storage.IDE_KEY, selectedIDE);\n        NotificationManager.showSuccess(`Default IDE set to ${selectedIDE}`);\n      }\n    });\n  },\n};\n\n// =======================\n// Notification Management\n// =======================\nconst NotificationManager = {\n  show(message, type = \"info\", duration = 3000) {\n    const colors = {\n      success: \"#4CAF50\",\n      error: \"#F44336\",\n      info: \"#2196F3\",\n    };\n\n    const notification = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        bottom: 20px;\n        right: 20px;\n        padding: 10px 20px;\n        background: ${colors[type]};\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n        transition: opacity 0.3s ease;\n      `,\n      },\n      [message]\n    );\n\n    document.body.appendChild(notification);\n\n    setTimeout(() => {\n      notification.style.opacity = \"0\";\n      setTimeout(() => {\n        if (document.body.contains(notification)) {\n          document.body.removeChild(notification);\n        }\n      }, 300);\n    }, duration);\n  },\n\n  showSuccess(message) {\n    this.show(message, \"success\");\n  },\n\n  showError(message) {\n    this.show(message, \"error\");\n  },\n\n  showInfo(message) {\n    this.show(message, \"info\");\n  },\n};\n\n// =======================\n// Modal Management\n// =======================\nclass Modal {\n  constructor(modalId, formId, openBtnId) {\n    this.modal = document.getElementById(modalId);\n    this.form = document.getElementById(formId);\n    this.openBtn = document.getElementById(openBtnId);\n    this.closeBtn = this.modal.querySelector(\".close\");\n\n    this.bindEvents();\n  }\n\n  bindEvents() {\n    this.openBtn?.addEventListener(\"click\", () => this.open());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n\n    // Close on outside click\n    window.addEventListener(\"click\", (e) => {\n      if (e.target === this.modal) {\n        this.close();\n      }\n    });\n\n    // Close on Escape key\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Escape\" && this.isOpen()) {\n        this.close();\n      }\n    });\n  }\n\n  open() {\n    this.modal.style.display = \"flex\";\n    document.body.style.overflow = \"hidden\";\n    this.onOpen();\n  }\n\n  close() {\n    this.modal.style.display = \"none\";\n    document.body.style.overflow = \"auto\";\n    this.form?.reset();\n    this.onClose();\n  }\n\n  isOpen() {\n    return this.modal.style.display === \"flex\";\n  }\n\n  onOpen() {\n    // Override in subclasses\n  }\n\n  onClose() {\n    // Override in subclasses\n  }\n}\n\n// =======================\n// Repository Modal\n// =======================\nclass RepositoryModal extends Modal {\n  constructor() {\n    super(\"add-repo-modal\", \"add-repo-form\", \"add-repo-btn\");\n    this.nameInput = document.getElementById(\"repo-name\");\n    this.pathInput = document.getElementById(\"repo-path\");\n    this.browseBtn = document.getElementById(\"browse-path\");\n\n    this.bindRepositoryEvents();\n  }\n\n  onOpen() {\n    this.nameInput.focus();\n  }\n\n  bindRepositoryEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn.addEventListener(\"click\", () => this.browsePath());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const path = this.pathInput.value.trim();\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      await window.electronAPI.addRepository({ name, path });\n      this.close();\n      NotificationManager.showSuccess(\"Repository added successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error adding repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name || !path) {\n      NotificationManager.showError(\"Please fill in all fields\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Repository Modal\n// =======================\nclass EditRepositoryModal extends Modal {\n  constructor() {\n    super(\"edit-repo-modal\", \"edit-repo-form\");\n    this.nameInput = document.getElementById(\"edit-repo-name\");\n    this.pathInput = document.getElementById(\"edit-repo-path\");\n    this.originalNameInput = document.getElementById(\"edit-original-name\");\n    this.browseBtn = document.getElementById(\"edit-browse-path\");\n    this.closeBtn = document.querySelector(\"#edit-repo-modal .close\");\n\n    this.bindEvents();\n  }\n\n  open(repo) {\n    // Store original values\n    this.originalNameInput.value = repo.name;\n\n    // Set current values (read-only)\n    document.getElementById(\"current-repo-name\").textContent = repo.name;\n    document.getElementById(\"current-repo-path\").textContent = repo.path;\n\n    // Clear and reset form fields\n    this.nameInput.value = repo.name;\n    this.pathInput.value = repo.path;\n    this.nameInput.placeholder = `Current: ${repo.name}`;\n    this.pathInput.placeholder = `Current: ${repo.path}`;\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn?.addEventListener(\"click\", () => this.browsePath());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim() || originalName; // Use original name if new name is empty\n    const path =\n      this.pathInput.value.trim() ||\n      this.pathInput.placeholder.replace(\"Current: \", \"\"); // Use current path if empty\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      // Get current repositories data\n      const data = await window.electronAPI.getReposData();\n\n      // Ensure we have the expected data structure\n      if (!data || typeof data !== \"object\" || !data.repos) {\n        throw new Error(\"Invalid repository data structure\");\n      }\n\n\n      // Check if the repository exists\n      if (!data.repos[originalName]) {\n        console.error(\"Repository not found in:\", data.repos);\n        throw new Error(\"Repository not found\");\n      }\n\n      // Check if name is being changed to an existing one (except current repo)\n      if (name !== originalName && data.repos[name]) {\n        NotificationManager.showError(\n          \"A repository with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the repositories\n      const updatedRepos = { ...data.repos };\n\n      // If name changed, remove old entry\n      if (name !== originalName) {\n        delete updatedRepos[originalName];\n      }\n\n      // Update or add the repository with new values and updatedAt timestamp\n      const now = new Date().toISOString();\n      updatedRepos[name] = {\n        path,\n        updatedAt: data.repos[originalName]?.updatedAt || now,\n      };\n\n      // Save the updated repositories using the correct IPC method\n      await window.electronAPI.writeReposFile({\n        ...data,\n        repos: updatedRepos,\n      });\n\n      // Refresh UI\n      UIManager.refresh();\n\n      NotificationManager.showSuccess(\"Repository updated successfully\");\n      this.close();\n    } catch (error) {\n      console.error(\"Error updating repository:\", error);\n      NotificationManager.showError(\n        `Failed to update repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a repository name\");\n      return false;\n    }\n    if (!path) {\n      NotificationManager.showError(\"Please select a repository path\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Collection Modal\n// =======================\nclass EditCollectionModal extends Modal {\n  constructor() {\n    super(\"edit-collection-modal\", \"edit-collection-form\");\n    this.nameInput = document.getElementById(\"edit-collection-name\");\n    this.originalNameInput = document.getElementById(\n      \"edit-original-collection-name\"\n    );\n    this.currentNameEl = document.getElementById(\"current-collection-name\");\n    this.currentReposEl = document.getElementById(\"current-collection-repos\");\n    this.reposSelection = document.getElementById(\"edit-repos-selection\");\n    this.closeBtn = document.querySelector(\"#edit-collection-modal .close\");\n\n    this.bindEvents();\n  }\n\n  async open(collection) {\n    // Store original values\n    this.originalNameInput.value = collection.name;\n\n    // Set current values\n    this.currentNameEl.textContent = collection.name;\n\n    // Handle both array and string formats for backward compatibility\n    const repoList = Array.isArray(collection.repos)\n      ? collection.repos\n      : (collection.repos || \"\")\n          .split(\",\")\n          .map((s) => s.trim())\n          .filter(Boolean);\n\n    this.currentReposEl.textContent = repoList.length\n      ? repoList.join(\", \")\n      : \"No repositories\";\n    this.nameInput.value = collection.name;\n    this.nameInput.placeholder = `Current: ${collection.name}`;\n\n    // Load repositories with current selection\n    await this.loadRepositories(repoList);\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async loadRepositories(selectedRepos = []) {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {}, selectedRepos);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos, selectedRepos = []) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"edit-repo-${name}\" name=\"repos\" value=\"${name}\" \n                 ${selectedRepos.includes(name) ? \"checked\" : \"\"}>\n          <label for=\"edit-repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      const data = await window.electronAPI.getReposData();\n\n      // Check if name is being changed to an existing one (except current collection)\n      if (name !== originalName && data.collections && data.collections[name]) {\n        NotificationManager.showError(\n          \"A collection with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the collections\n      const updatedCollections = { ...data.collections };\n\n      // Remove old entry if name changed\n      if (name !== originalName) {\n        delete updatedCollections[originalName];\n      }\n\n      // Update or add the collection with new values\n      updatedCollections[name] = {\n        name,\n        repos: selectedRepos, // Save as array\n        updatedAt:\n          updatedCollections[originalName]?.updatedAt ||\n          new Date().toISOString(),\n      };\n\n      // Save the updated collections\n      await window.electronAPI.writeReposFile({\n        ...data,\n        collections: updatedCollections,\n      });\n\n      this.close();\n      NotificationManager.showSuccess(\"Collection updated successfully\");\n      UIManager.refresh();\n    } catch (error) {\n      console.error(\"Error updating collection:\", error);\n      NotificationManager.showError(\n        `Failed to update collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// =======================\n// Collection Modal\n// =======================\nclass CollectionModal extends Modal {\n  constructor() {\n    super(\"add-collection-modal\", \"add-collection-form\", \"add-collection-btn\");\n    this.nameInput = document.getElementById(\"collection-name\");\n    this.reposSelection = document.getElementById(\"repos-selection\");\n\n    this.bindCollectionEvents();\n  }\n\n  async onOpen() {\n    this.nameInput.focus();\n    await this.loadRepositories();\n  }\n\n  onClose() {\n    this.reposSelection.innerHTML =\n      '<div class=\"loading\">Loading repositories...</div>';\n  }\n\n  bindCollectionEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n  }\n\n  async loadRepositories() {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {});\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"repo-${name}\" name=\"repos\" value=\"${name}\">\n          <label for=\"repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      await this.saveCollection(name, selectedRepos);\n      this.close();\n      NotificationManager.showSuccess(\"Collection created successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error creating collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n\n  async saveCollection(name, selectedRepos) {\n    const data = await window.electronAPI.getReposData();\n\n    if (data.collections && data.collections[name]) {\n      throw new Error(\"A collection with this name already exists\");\n    }\n\n    if (!data.collections) data.collections = {};\n    data.collections[name] = {\n      name,\n      repos: selectedRepos,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await window.electronAPI.writeReposFile(data);\n  }\n}\n\n// =======================\n// UI Management\n// =======================\nconst UIManager = {\n  init(callbacks = {}) {\n    this.searchInput = document.getElementById(\"search-input\");\n    this.refreshBtn = document.getElementById(\"refresh-btn\");\n\n    // Store callbacks\n    this.handleEditRepository = callbacks.onEditRepository || (() => {});\n    this.handleEditCollection = callbacks.onEditCollection || (() => {});\n\n    // Initialize edit collection modal if it doesn't exist\n    if (!this.editCollectionModal) {\n      this.editCollectionModal = new EditCollectionModal();\n    }\n\n    this.bindEvents();\n    this.refresh();\n  },\n\n  bindEvents() {\n    // Debounce search to improve performance\n    const debouncedUpdate = Utils.debounce(() => this.updateDisplay(), 300);\n    this.searchInput.addEventListener(\"input\", debouncedUpdate);\n    this.refreshBtn.addEventListener(\"click\", () => this.refresh());\n  },\n\n  async refresh() {\n    this.showRefreshAnimation();\n\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.processData(data);\n      this.updateDisplay();\n    } catch (error) {\n      NotificationManager.showError(`Error refreshing data: ${error.message}`);\n    } finally {\n      this.hideRefreshAnimation();\n    }\n  },\n\n  processData(data) {\n    // Process repositories\n    if (data.repos) {\n      const repos = Object.entries(data.repos).map(([name, repo]) => ({\n        name,\n        path: repo.path,\n        updatedAt: repo.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setRepos(repos);\n    } else {\n      AppState.setRepos([]);\n    }\n\n    // Process collections\n    if (data.collections) {\n      const collections = Object.values(data.collections).map((collection) => ({\n        name: collection.name,\n        repos: Array.isArray(collection.repos)\n          ? collection.repos.join(\", \")\n          : \"\",\n        updatedAt: collection.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setCollections(collections);\n    } else {\n      AppState.setCollections([]);\n    }\n  },\n\n  updateDisplay() {\n    const searchTerm = this.searchInput.value.trim();\n    this.updateRepositoriesTable(AppState.getFilteredRepos(searchTerm));\n    this.updateCollectionsTable(AppState.getFilteredCollections(searchTerm));\n  },\n\n  updateRepositoriesTable(repos) {\n    const container = document.getElementById(\"repos-list\");\n    const table = document.getElementById(\"repos-table\");\n    const loading = document.getElementById(\"loading-repos\");\n\n    if (repos.length === 0) {\n      loading.textContent = \"No matching repositories found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = repos\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((repo) => this.createRepositoryRow(repo))\n      .join(\"\");\n\n    this.bindRepositoryEvents();\n  },\n\n  createRepositoryRow(repo) {\n    return `\n      <tr data-path=\"${Utils.formatPath(repo.path)}\" data-name=\"${repo.name}\" class=\"clickable-repo-row\">\n        <td><strong>${repo.name}</strong></td>\n        <td class=\"path\">${Utils.formatPath(repo.path)}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${repo.name}\" data-path=\"${Utils.formatPath(repo.path)}\" data-type=\"repo\" title=\"Edit repository\">✏️</button>\n            <button class=\"delete-btn\" data-name=\"${repo.name}\" data-type=\"repo\" title=\"Delete repository\">🗑️</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindRepositoryEvents() {\n    // Bind click events for opening repositories\n    document.querySelectorAll(\".clickable-repo-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleRepositoryClick(e, row));\n    });\n\n    // Bind edit events\n    document.querySelectorAll('.edit-btn[data-type=\"repo\"]').forEach((btn) => {\n      btn.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        const name = btn.dataset.name;\n        const path = btn.dataset.path;\n        if (this.handleEditRepository) {\n          this.handleEditRepository({ name, path });\n        }\n      });\n    });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"repo\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleRepositoryDelete(e, btn)\n        );\n      });\n  },\n\n  async handleRepositoryClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    const selectedIDE = IDEManager.getSelectedIDE();\n    if (!selectedIDE) {\n      NotificationManager.showError(\"Please select an IDE first\");\n      return;\n    }\n\n    const repoPath = row.getAttribute(\"data-path\");\n    const repoName = row.getAttribute(\"data-name\");\n    console.log(repoPath, repoName);\n    if (!repoPath) return;\n\n    try {\n      const result = await window.electronAPI.openInIDE({\n        name: repoName,\n        path: repoPath,\n        ide: selectedIDE,\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || \"Failed to open in IDE\");\n      }\n\n      NotificationManager.showSuccess(\n        `Successfully opened ${repoPath} in ${selectedIDE}`\n      );\n    } catch (error) {\n      NotificationManager.showError(`Error opening IDE: ${error.message}`);\n    }\n  },\n\n  async handleRepositoryDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete repository \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteRepo(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  updateCollectionsTable(collections) {\n    const container = document.getElementById(\"collections-list\");\n    const table = document.getElementById(\"collections-table\");\n    const loading = document.getElementById(\"loading-collections\");\n\n    if (collections.length === 0) {\n      loading.textContent = \"No matching collections found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = collections\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((collection) => this.createCollectionRow(collection))\n      .join(\"\");\n\n    this.bindCollectionEvents();\n  },\n\n  createCollectionRow(collection) {\n    const collectionData = JSON.stringify(collection).replace(/\"/g, \"&quot;\");\n    return `\n      <tr class=\"clickable-collection-row\" data-collection=\"${collectionData}\">\n        <td><strong>${collection.name}</strong></td>\n        <td>${collection.repos}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Edit collection\">✏️</button>\n            <button class=\"delete-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Delete collection\">🗑️</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindCollectionEvents() {\n    // Bind click events for opening collections\n    document.querySelectorAll(\".clickable-collection-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleCollectionClick(e, row));\n    });\n\n    // Bind edit events\n    document\n      .querySelectorAll('.edit-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          const collectionData = JSON.parse(\n            btn\n              .closest(\"tr\")\n              .getAttribute(\"data-collection\")\n              .replace(/&quot;/g, '\"')\n          );\n          if (this.editCollectionModal) {\n            this.editCollectionModal.open(collectionData);\n          }\n        });\n      });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleCollectionDelete(e, btn)\n        );\n      });\n  },\n\n  async handleCollectionClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    try {\n      const collection = JSON.parse(row.getAttribute(\"data-collection\"));\n      const reposData = await window.electronAPI.getReposData();\n\n      const repos = collection.repos.split(\",\").map((repo) => {\n        const [name, path, ide] = repo\n          .trim()\n          .split(\"|\")\n          .map((s) => s.trim());\n        return { name, path, ide };\n      });\n\n      // Open all repositories in parallel\n      const promises = repos.map(async (repo) => {\n        const repoData = reposData.repos[repo.name];\n\n        if (!repoData) {\n          NotificationManager.showError(\n            `${repo.name}: Not found in repositories`\n          );\n          return;\n        }\n\n        const ide = repo.ide || IDEManager.getSelectedIDE();\n\n        try {\n          await window.electronAPI.openInIDE({\n            name: repo.name,\n            path: repoData.path,\n            ide: ide,\n          });\n        } catch (error) {\n          NotificationManager.showError(\n            `Failed to open ${repo.name}: ${error.message}`\n          );\n        }\n      });\n\n      await Promise.allSettled(promises);\n      NotificationManager.showSuccess(`Successfully opened ${collection.name}`);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error processing collection: ${error.message}`\n      );\n    }\n  },\n\n  async handleCollectionDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete collection \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteCollection(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  showRefreshAnimation() {\n    this.refreshBtn.classList.add(\"rotating\");\n  },\n\n  hideRefreshAnimation() {\n    setTimeout(() => {\n      this.refreshBtn.classList.remove(\"rotating\");\n    }, 1000);\n  },\n\n  showLoadingIndicator(text) {\n    const indicator = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        padding: 10px;\n        background: rgba(0,0,0,0.7);\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n      `,\n      },\n      [text]\n    );\n\n    document.body.appendChild(indicator);\n    return indicator;\n  },\n\n  hideLoadingIndicator(indicator) {\n    if (document.body.contains(indicator)) {\n      document.body.removeChild(indicator);\n    }\n  },\n};\n\n// =======================\n// Application Initialization\n// =======================\nclass App {\n  constructor() {\n    this.init();\n  }\n\n  init() {\n    // Initialize core systems\n    ThemeManager.init();\n    IDEManager.init();\n\n    // Initialize modals\n    this.repositoryModal = new RepositoryModal();\n    this.editRepositoryModal = new EditRepositoryModal();\n    this.collectionModal = new CollectionModal();\n    this.editCollectionModal = new EditCollectionModal();\n\n    // Initialize UI manager with modals\n    UIManager.init({\n      onEditRepository: (repo) => this.editRepositoryModal.open(repo),\n      onEditCollection: (collection) =>\n        this.editCollectionModal.open(collection),\n    });\n\n    // Handle electron API data\n    this.bindElectronEvents();\n\n    console.log(\"👋 OpenMate application initialized successfully\");\n  }\n\n  bindElectronEvents() {\n    if (window.electronAPI && window.electronAPI.onReposData) {\n      window.electronAPI.onReposData((data) => {\n        const { repos = [], collections = [] } = data;\n        AppState.setRepos(repos);\n        AppState.setCollections(collections);\n        UIManager.updateDisplay();\n      });\n    }\n  }\n}\n\n// =======================\n// Initialize Application\n// =======================\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new App();\n});\n\n// Import styles\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RCw2Q0FBNkMsVUFBVTs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNxQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5tYXRlLXVpLy4vc3JjL3JlbmRlcmVyLmpzPzg4YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFN0YXRlIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBBcHBTdGF0ZSA9IHtcbiAgcmVwb3M6IFtdLFxuICBjb2xsZWN0aW9uczogW10sXG5cbiAgc2V0UmVwb3MocmVwb3MpIHtcbiAgICB0aGlzLnJlcG9zID0gcmVwb3M7XG4gIH0sXG5cbiAgc2V0Q29sbGVjdGlvbnMoY29sbGVjdGlvbnMpIHtcbiAgICB0aGlzLmNvbGxlY3Rpb25zID0gY29sbGVjdGlvbnM7XG4gIH0sXG5cbiAgZ2V0RmlsdGVyZWRSZXBvcyhzZWFyY2hUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVySXRlbXModGhpcy5yZXBvcywgc2VhcmNoVGVybSk7XG4gIH0sXG5cbiAgZ2V0RmlsdGVyZWRDb2xsZWN0aW9ucyhzZWFyY2hUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVySXRlbXModGhpcy5jb2xsZWN0aW9ucywgc2VhcmNoVGVybSk7XG4gIH0sXG5cbiAgZmlsdGVySXRlbXMoaXRlbXMsIHNlYXJjaFRlcm0pIHtcbiAgICBpZiAoIXNlYXJjaFRlcm0pIHJldHVybiBpdGVtcztcbiAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgICAoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHxcbiAgICAgICAgKGl0ZW0ucGF0aCAmJiBpdGVtLnBhdGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSkgfHxcbiAgICAgICAgKGl0ZW0ucmVwb3MgJiYgaXRlbS5yZXBvcy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pKVxuICAgICk7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVXRpbGl0eSBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBVdGlscyA9IHtcbiAgZm9ybWF0UGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGggPyBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpIDogXCJcIjtcbiAgfSxcblxuICBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGVkRnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgZnVuYyguLi5hcmdzKTtcbiAgICAgIH07XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfTtcbiAgfSxcblxuICBjcmVhdGVFbGVtZW50KHRhZywgYXR0cmlidXRlcyA9IHt9LCBjaGlsZHJlbiA9IFtdKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NOYW1lXCIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFN0b3JhZ2UgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IFN0b3JhZ2UgPSB7XG4gIFRIRU1FX0tFWTogXCJvcGVubWF0ZS10aGVtZVwiLFxuICBJREVfS0VZOiBcIm9wZW5tYXRlLWlkZS1zZWxlY3RvclwiLFxuXG4gIGdldChrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU3RvcmFnZSBnZXQgZmFpbGVkOlwiLCBlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTdG9yYWdlIHNldCBmYWlsZWQ6XCIsIGUpO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUaGVtZSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgVGhlbWVNYW5hZ2VyID0ge1xuICBpbml0KCkge1xuICAgIHRoaXMudGhlbWVUb2dnbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRoZW1lLXRvZ2dsZVwiKTtcbiAgICB0aGlzLnRoZW1lSWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGhlbWUtaWNvblwiKTtcblxuICAgIHRoaXMubG9hZFRoZW1lKCk7XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH0sXG5cbiAgbG9hZFRoZW1lKCkge1xuICAgIGNvbnN0IHNhdmVkVGhlbWUgPSBTdG9yYWdlLmdldChTdG9yYWdlLlRIRU1FX0tFWSk7XG4gICAgY29uc3Qgc3lzdGVtUHJlZmVyc0RhcmsgPSB3aW5kb3cubWF0Y2hNZWRpYShcbiAgICAgIFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIGNvbnN0IHRoZW1lID0gc2F2ZWRUaGVtZSB8fCAoc3lzdGVtUHJlZmVyc0RhcmsgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG5cbiAgICB0aGlzLnNldFRoZW1lKHRoZW1lKTtcbiAgfSxcblxuICBzZXRUaGVtZSh0aGVtZSkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRoZW1lXCIsIHRoZW1lKTtcbiAgICB0aGlzLnRoZW1lSWNvbi50ZXh0Q29udGVudCA9IHRoZW1lID09PSBcImRhcmtcIiA/IFwi4piA77iPXCIgOiBcIvCfjJlcIjtcbiAgICBTdG9yYWdlLnNldChTdG9yYWdlLlRIRU1FX0tFWSwgdGhlbWUpO1xuICB9LFxuXG4gIHRvZ2dsZSgpIHtcbiAgICBjb25zdCBjdXJyZW50VGhlbWUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10aGVtZVwiKTtcbiAgICBjb25zdCBuZXdUaGVtZSA9IGN1cnJlbnRUaGVtZSA9PT0gXCJkYXJrXCIgPyBcImxpZ2h0XCIgOiBcImRhcmtcIjtcbiAgICB0aGlzLnNldFRoZW1lKG5ld1RoZW1lKTtcbiAgfSxcblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMudGhlbWVUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMudG9nZ2xlKCkpO1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIElERSBTZWxlY3RvciBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgSURFTWFuYWdlciA9IHtcbiAgaW5pdCgpIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZGUtc2VsZWN0b3JcIik7XG4gICAgdGhpcy5sb2FkUHJlZmVyZW5jZSgpO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9LFxuXG4gIGxvYWRQcmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IHNhdmVkSURFID0gU3RvcmFnZS5nZXQoU3RvcmFnZS5JREVfS0VZKTtcbiAgICBpZiAoc2F2ZWRJREUpIHtcbiAgICAgIHRoaXMuc2VsZWN0b3IudmFsdWUgPSBzYXZlZElERTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0ZWRJREUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IudmFsdWU7XG4gIH0sXG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLnNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkSURFID0gZS50YXJnZXQudmFsdWU7XG4gICAgICBpZiAoc2VsZWN0ZWRJREUpIHtcbiAgICAgICAgU3RvcmFnZS5zZXQoU3RvcmFnZS5JREVfS0VZLCBzZWxlY3RlZElERSk7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoYERlZmF1bHQgSURFIHNldCB0byAke3NlbGVjdGVkSURFfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE5vdGlmaWNhdGlvbiBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgTm90aWZpY2F0aW9uTWFuYWdlciA9IHtcbiAgc2hvdyhtZXNzYWdlLCB0eXBlID0gXCJpbmZvXCIsIGR1cmF0aW9uID0gMzAwMCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHtcbiAgICAgIHN1Y2Nlc3M6IFwiIzRDQUY1MFwiLFxuICAgICAgZXJyb3I6IFwiI0Y0NDMzNlwiLFxuICAgICAgaW5mbzogXCIjMjE5NkYzXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFV0aWxzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdHlsZTogYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGJvdHRvbTogMjBweDtcbiAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgIHBhZGRpbmc6IDEwcHggMjBweDtcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnNbdHlwZV19O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgei1pbmRleDogMTAwMDtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2U7XG4gICAgICBgLFxuICAgICAgfSxcbiAgICAgIFttZXNzYWdlXVxuICAgICk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbik7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG5vdGlmaWNhdGlvbi5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMobm90aWZpY2F0aW9uKSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICB9LCBkdXJhdGlvbik7XG4gIH0sXG5cbiAgc2hvd1N1Y2Nlc3MobWVzc2FnZSkge1xuICAgIHRoaXMuc2hvdyhtZXNzYWdlLCBcInN1Y2Nlc3NcIik7XG4gIH0sXG5cbiAgc2hvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnNob3cobWVzc2FnZSwgXCJlcnJvclwiKTtcbiAgfSxcblxuICBzaG93SW5mbyhtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KG1lc3NhZ2UsIFwiaW5mb1wiKTtcbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNb2RhbCBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgTW9kYWwge1xuICBjb25zdHJ1Y3Rvcihtb2RhbElkLCBmb3JtSWQsIG9wZW5CdG5JZCkge1xuICAgIHRoaXMubW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcbiAgICB0aGlzLmZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtSWQpO1xuICAgIHRoaXMub3BlbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wZW5CdG5JZCk7XG4gICAgdGhpcy5jbG9zZUJ0biA9IHRoaXMubW9kYWwucXVlcnlTZWxlY3RvcihcIi5jbG9zZVwiKTtcblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLm9wZW5CdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLm9wZW4oKSk7XG4gICAgdGhpcy5jbG9zZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2UoKSk7XG5cbiAgICAvLyBDbG9zZSBvbiBvdXRzaWRlIGNsaWNrXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLm1vZGFsKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NlIG9uIEVzY2FwZSBrZXlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLm1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICB0aGlzLm9uT3BlbigpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiO1xuICAgIHRoaXMuZm9ybT8ucmVzZXQoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID09PSBcImZsZXhcIjtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICAvLyBPdmVycmlkZSBpbiBzdWJjbGFzc2VzXG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIC8vIE92ZXJyaWRlIGluIHN1YmNsYXNzZXNcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUmVwb3NpdG9yeSBNb2RhbFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIFJlcG9zaXRvcnlNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJhZGQtcmVwby1tb2RhbFwiLCBcImFkZC1yZXBvLWZvcm1cIiwgXCJhZGQtcmVwby1idG5cIik7XG4gICAgdGhpcy5uYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcG8tbmFtZVwiKTtcbiAgICB0aGlzLnBhdGhJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwby1wYXRoXCIpO1xuICAgIHRoaXMuYnJvd3NlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJicm93c2UtcGF0aFwiKTtcblxuICAgIHRoaXMuYmluZFJlcG9zaXRvcnlFdmVudHMoKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICB0aGlzLm5hbWVJbnB1dC5mb2N1cygpO1xuICB9XG5cbiAgYmluZFJlcG9zaXRvcnlFdmVudHMoKSB7XG4gICAgdGhpcy5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKGUpID0+IHRoaXMuaGFuZGxlU3VibWl0KGUpKTtcbiAgICB0aGlzLmJyb3dzZUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5icm93c2VQYXRoKCkpO1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlU3VibWl0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lSW5wdXQudmFsdWUudHJpbSgpO1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGhJbnB1dC52YWx1ZS50cmltKCk7XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVJbnB1dHMobmFtZSwgcGF0aCkpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuYWRkUmVwb3NpdG9yeSh7IG5hbWUsIHBhdGggfSk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFwiUmVwb3NpdG9yeSBhZGRlZCBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgVUlNYW5hZ2VyLnJlZnJlc2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBhZGRpbmcgcmVwb3NpdG9yeTogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVJbnB1dHMobmFtZSwgcGF0aCkge1xuICAgIGlmICghbmFtZSB8fCAhcGF0aCkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2UgZmlsbCBpbiBhbGwgZmllbGRzXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGJyb3dzZVBhdGgoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhdGggPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkub3BlbkRpcmVjdG9yeURpYWxvZygpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoSW5wdXQudmFsdWUgPSBwYXRoO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIHNlbGVjdGluZyBkaXJlY3Rvcnk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRWRpdCBSZXBvc2l0b3J5IE1vZGFsXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgRWRpdFJlcG9zaXRvcnlNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJlZGl0LXJlcG8tbW9kYWxcIiwgXCJlZGl0LXJlcG8tZm9ybVwiKTtcbiAgICB0aGlzLm5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1yZXBvLW5hbWVcIik7XG4gICAgdGhpcy5wYXRoSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtcmVwby1wYXRoXCIpO1xuICAgIHRoaXMub3JpZ2luYWxOYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtb3JpZ2luYWwtbmFtZVwiKTtcbiAgICB0aGlzLmJyb3dzZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1icm93c2UtcGF0aFwiKTtcbiAgICB0aGlzLmNsb3NlQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlZGl0LXJlcG8tbW9kYWwgLmNsb3NlXCIpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBvcGVuKHJlcG8pIHtcbiAgICAvLyBTdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB0aGlzLm9yaWdpbmFsTmFtZUlucHV0LnZhbHVlID0gcmVwby5uYW1lO1xuXG4gICAgLy8gU2V0IGN1cnJlbnQgdmFsdWVzIChyZWFkLW9ubHkpXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LXJlcG8tbmFtZVwiKS50ZXh0Q29udGVudCA9IHJlcG8ubmFtZTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnJlbnQtcmVwby1wYXRoXCIpLnRleHRDb250ZW50ID0gcmVwby5wYXRoO1xuXG4gICAgLy8gQ2xlYXIgYW5kIHJlc2V0IGZvcm0gZmllbGRzXG4gICAgdGhpcy5uYW1lSW5wdXQudmFsdWUgPSByZXBvLm5hbWU7XG4gICAgdGhpcy5wYXRoSW5wdXQudmFsdWUgPSByZXBvLnBhdGg7XG4gICAgdGhpcy5uYW1lSW5wdXQucGxhY2Vob2xkZXIgPSBgQ3VycmVudDogJHtyZXBvLm5hbWV9YDtcbiAgICB0aGlzLnBhdGhJbnB1dC5wbGFjZWhvbGRlciA9IGBDdXJyZW50OiAke3JlcG8ucGF0aH1gO1xuXG4gICAgLy8gT3BlbiBtb2RhbCBhbmQgZm9jdXNcbiAgICBzdXBlci5vcGVuKCk7XG4gICAgdGhpcy5uYW1lSW5wdXQuZm9jdXMoKTtcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5mb3JtPy5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChlKSA9PiB0aGlzLmhhbmRsZVN1Ym1pdChlKSk7XG4gICAgdGhpcy5icm93c2VCdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmJyb3dzZVBhdGgoKSk7XG4gICAgdGhpcy5jbG9zZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IHRoaXMub3JpZ2luYWxOYW1lSW5wdXQudmFsdWU7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZUlucHV0LnZhbHVlLnRyaW0oKSB8fCBvcmlnaW5hbE5hbWU7IC8vIFVzZSBvcmlnaW5hbCBuYW1lIGlmIG5ldyBuYW1lIGlzIGVtcHR5XG4gICAgY29uc3QgcGF0aCA9XG4gICAgICB0aGlzLnBhdGhJbnB1dC52YWx1ZS50cmltKCkgfHxcbiAgICAgIHRoaXMucGF0aElucHV0LnBsYWNlaG9sZGVyLnJlcGxhY2UoXCJDdXJyZW50OiBcIiwgXCJcIik7IC8vIFVzZSBjdXJyZW50IHBhdGggaWYgZW1wdHlcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cyhuYW1lLCBwYXRoKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IHJlcG9zaXRvcmllcyBkYXRhXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuXG4gICAgICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgZXhwZWN0ZWQgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCAhZGF0YS5yZXBvcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcG9zaXRvcnkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICB9XG5cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlcG9zaXRvcnkgZXhpc3RzXG4gICAgICBpZiAoIWRhdGEucmVwb3Nbb3JpZ2luYWxOYW1lXSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVwb3NpdG9yeSBub3QgZm91bmQgaW46XCIsIGRhdGEucmVwb3MpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXBvc2l0b3J5IG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgbmFtZSBpcyBiZWluZyBjaGFuZ2VkIHRvIGFuIGV4aXN0aW5nIG9uZSAoZXhjZXB0IGN1cnJlbnQgcmVwbylcbiAgICAgIGlmIChuYW1lICE9PSBvcmlnaW5hbE5hbWUgJiYgZGF0YS5yZXBvc1tuYW1lXSkge1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgICBcIkEgcmVwb3NpdG9yeSB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5IGV4aXN0c1wiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgcmVwb3NpdG9yaWVzXG4gICAgICBjb25zdCB1cGRhdGVkUmVwb3MgPSB7IC4uLmRhdGEucmVwb3MgfTtcblxuICAgICAgLy8gSWYgbmFtZSBjaGFuZ2VkLCByZW1vdmUgb2xkIGVudHJ5XG4gICAgICBpZiAobmFtZSAhPT0gb3JpZ2luYWxOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkUmVwb3Nbb3JpZ2luYWxOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIG9yIGFkZCB0aGUgcmVwb3NpdG9yeSB3aXRoIG5ldyB2YWx1ZXMgYW5kIHVwZGF0ZWRBdCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIHVwZGF0ZWRSZXBvc1tuYW1lXSA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnJlcG9zW29yaWdpbmFsTmFtZV0/LnVwZGF0ZWRBdCB8fCBub3csXG4gICAgICB9O1xuXG4gICAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIHJlcG9zaXRvcmllcyB1c2luZyB0aGUgY29ycmVjdCBJUEMgbWV0aG9kXG4gICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkud3JpdGVSZXBvc0ZpbGUoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICByZXBvczogdXBkYXRlZFJlcG9zLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlZnJlc2ggVUlcbiAgICAgIFVJTWFuYWdlci5yZWZyZXNoKCk7XG5cbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXCJSZXBvc2l0b3J5IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgcmVwb3NpdG9yeTpcIiwgZXJyb3IpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gdXBkYXRlIHJlcG9zaXRvcnk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlSW5wdXRzKG5hbWUsIHBhdGgpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIGVudGVyIGEgcmVwb3NpdG9yeSBuYW1lXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhIHJlcG9zaXRvcnkgcGF0aFwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBicm93c2VQYXRoKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXRoID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLm9wZW5EaXJlY3RvcnlEaWFsb2coKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aElucHV0LnZhbHVlID0gcGF0aDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBzZWxlY3RpbmcgZGlyZWN0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEVkaXQgQ29sbGVjdGlvbiBNb2RhbFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIEVkaXRDb2xsZWN0aW9uTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiZWRpdC1jb2xsZWN0aW9uLW1vZGFsXCIsIFwiZWRpdC1jb2xsZWN0aW9uLWZvcm1cIik7XG4gICAgdGhpcy5uYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtY29sbGVjdGlvbi1uYW1lXCIpO1xuICAgIHRoaXMub3JpZ2luYWxOYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgIFwiZWRpdC1vcmlnaW5hbC1jb2xsZWN0aW9uLW5hbWVcIlxuICAgICk7XG4gICAgdGhpcy5jdXJyZW50TmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LWNvbGxlY3Rpb24tbmFtZVwiKTtcbiAgICB0aGlzLmN1cnJlbnRSZXBvc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LWNvbGxlY3Rpb24tcmVwb3NcIik7XG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1yZXBvcy1zZWxlY3Rpb25cIik7XG4gICAgdGhpcy5jbG9zZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZWRpdC1jb2xsZWN0aW9uLW1vZGFsIC5jbG9zZVwiKTtcblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG5cbiAgYXN5bmMgb3Blbihjb2xsZWN0aW9uKSB7XG4gICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzXG4gICAgdGhpcy5vcmlnaW5hbE5hbWVJbnB1dC52YWx1ZSA9IGNvbGxlY3Rpb24ubmFtZTtcblxuICAgIC8vIFNldCBjdXJyZW50IHZhbHVlc1xuICAgIHRoaXMuY3VycmVudE5hbWVFbC50ZXh0Q29udGVudCA9IGNvbGxlY3Rpb24ubmFtZTtcblxuICAgIC8vIEhhbmRsZSBib3RoIGFycmF5IGFuZCBzdHJpbmcgZm9ybWF0cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGNvbnN0IHJlcG9MaXN0ID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uLnJlcG9zKVxuICAgICAgPyBjb2xsZWN0aW9uLnJlcG9zXG4gICAgICA6IChjb2xsZWN0aW9uLnJlcG9zIHx8IFwiXCIpXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5tYXAoKHMpID0+IHMudHJpbSgpKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICB0aGlzLmN1cnJlbnRSZXBvc0VsLnRleHRDb250ZW50ID0gcmVwb0xpc3QubGVuZ3RoXG4gICAgICA/IHJlcG9MaXN0LmpvaW4oXCIsIFwiKVxuICAgICAgOiBcIk5vIHJlcG9zaXRvcmllc1wiO1xuICAgIHRoaXMubmFtZUlucHV0LnZhbHVlID0gY29sbGVjdGlvbi5uYW1lO1xuICAgIHRoaXMubmFtZUlucHV0LnBsYWNlaG9sZGVyID0gYEN1cnJlbnQ6ICR7Y29sbGVjdGlvbi5uYW1lfWA7XG5cbiAgICAvLyBMb2FkIHJlcG9zaXRvcmllcyB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgYXdhaXQgdGhpcy5sb2FkUmVwb3NpdG9yaWVzKHJlcG9MaXN0KTtcblxuICAgIC8vIE9wZW4gbW9kYWwgYW5kIGZvY3VzXG4gICAgc3VwZXIub3BlbigpO1xuICAgIHRoaXMubmFtZUlucHV0LmZvY3VzKCk7XG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuZm9ybT8uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVTdWJtaXQoZSkpO1xuXG4gICAgdGhpcy5jbG9zZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICBhc3luYyBsb2FkUmVwb3NpdG9yaWVzKHNlbGVjdGVkUmVwb3MgPSBbXSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZXBvc2l0b3J5U2VsZWN0aW9uKGRhdGEucmVwb3MgfHwge30sIHNlbGVjdGVkUmVwb3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJlcnJvclwiPkVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzLiBQbGVhc2UgdHJ5IGFnYWluLjwvZGl2Pic7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyUmVwb3NpdG9yeVNlbGVjdGlvbihyZXBvcywgc2VsZWN0ZWRSZXBvcyA9IFtdKSB7XG4gICAgaWYgKCFyZXBvcyB8fCBPYmplY3Qua2V5cyhyZXBvcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9XG4gICAgICAgICc8ZGl2IGNsYXNzPVwibG9hZGluZ1wiPk5vIHJlcG9zaXRvcmllcyBmb3VuZC4gQWRkIHJlcG9zaXRvcmllcyBmaXJzdC48L2Rpdj4nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcG9zTGlzdCA9IE9iamVjdC5lbnRyaWVzKHJlcG9zKVxuICAgICAgLnNvcnQoKFtuYW1lQV0sIFtuYW1lQl0pID0+IG5hbWVBLmxvY2FsZUNvbXBhcmUobmFtZUIpKVxuICAgICAgLm1hcChcbiAgICAgICAgKFtuYW1lLCByZXBvXSkgPT4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwicmVwby1jaGVja2JveC1pdGVtXCI+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZWRpdC1yZXBvLSR7bmFtZX1cIiBuYW1lPVwicmVwb3NcIiB2YWx1ZT1cIiR7bmFtZX1cIiBcbiAgICAgICAgICAgICAgICAgJHtzZWxlY3RlZFJlcG9zLmluY2x1ZGVzKG5hbWUpID8gXCJjaGVja2VkXCIgOiBcIlwifT5cbiAgICAgICAgICA8bGFiZWwgZm9yPVwiZWRpdC1yZXBvLSR7bmFtZX1cIj5cbiAgICAgICAgICAgIDxzcGFuPiR7bmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlcG8tcGF0aFwiPiR7cmVwby5wYXRofTwvc3Bhbj5cbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICAgIClcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPSByZXBvc0xpc3Q7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IHRoaXMub3JpZ2luYWxOYW1lSW5wdXQudmFsdWU7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBjb25zdCBzZWxlY3RlZFJlcG9zID0gdGhpcy5nZXRTZWxlY3RlZFJlcG9zaXRvcmllcygpO1xuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5wdXRzKG5hbWUsIHNlbGVjdGVkUmVwb3MpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgbmFtZSBpcyBiZWluZyBjaGFuZ2VkIHRvIGFuIGV4aXN0aW5nIG9uZSAoZXhjZXB0IGN1cnJlbnQgY29sbGVjdGlvbilcbiAgICAgIGlmIChuYW1lICE9PSBvcmlnaW5hbE5hbWUgJiYgZGF0YS5jb2xsZWN0aW9ucyAmJiBkYXRhLmNvbGxlY3Rpb25zW25hbWVdKSB7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICAgIFwiQSBjb2xsZWN0aW9uIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uc1xuICAgICAgY29uc3QgdXBkYXRlZENvbGxlY3Rpb25zID0geyAuLi5kYXRhLmNvbGxlY3Rpb25zIH07XG5cbiAgICAgIC8vIFJlbW92ZSBvbGQgZW50cnkgaWYgbmFtZSBjaGFuZ2VkXG4gICAgICBpZiAobmFtZSAhPT0gb3JpZ2luYWxOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkQ29sbGVjdGlvbnNbb3JpZ2luYWxOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIG9yIGFkZCB0aGUgY29sbGVjdGlvbiB3aXRoIG5ldyB2YWx1ZXNcbiAgICAgIHVwZGF0ZWRDb2xsZWN0aW9uc1tuYW1lXSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmVwb3M6IHNlbGVjdGVkUmVwb3MsIC8vIFNhdmUgYXMgYXJyYXlcbiAgICAgICAgdXBkYXRlZEF0OlxuICAgICAgICAgIHVwZGF0ZWRDb2xsZWN0aW9uc1tvcmlnaW5hbE5hbWVdPy51cGRhdGVkQXQgfHxcbiAgICAgICAgICBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIGNvbGxlY3Rpb25zXG4gICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkud3JpdGVSZXBvc0ZpbGUoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjb2xsZWN0aW9uczogdXBkYXRlZENvbGxlY3Rpb25zLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXCJDb2xsZWN0aW9uIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgVUlNYW5hZ2VyLnJlZnJlc2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwZGF0aW5nIGNvbGxlY3Rpb246XCIsIGVycm9yKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHVwZGF0ZSBjb2xsZWN0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXRTZWxlY3RlZFJlcG9zaXRvcmllcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnKVxuICAgICkubWFwKChjaGVja2JveCkgPT4gY2hlY2tib3gudmFsdWUpO1xuICB9XG5cbiAgdmFsaWRhdGVJbnB1dHMobmFtZSwgc2VsZWN0ZWRSZXBvcykge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2UgZW50ZXIgYSBjb2xsZWN0aW9uIG5hbWVcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkUmVwb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIHJlcG9zaXRvcnlcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbGxlY3Rpb24gTW9kYWxcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBDb2xsZWN0aW9uTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYWRkLWNvbGxlY3Rpb24tbW9kYWxcIiwgXCJhZGQtY29sbGVjdGlvbi1mb3JtXCIsIFwiYWRkLWNvbGxlY3Rpb24tYnRuXCIpO1xuICAgIHRoaXMubmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb2xsZWN0aW9uLW5hbWVcIik7XG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwb3Mtc2VsZWN0aW9uXCIpO1xuXG4gICAgdGhpcy5iaW5kQ29sbGVjdGlvbkV2ZW50cygpO1xuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIHRoaXMubmFtZUlucHV0LmZvY3VzKCk7XG4gICAgYXdhaXQgdGhpcy5sb2FkUmVwb3NpdG9yaWVzKCk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICc8ZGl2IGNsYXNzPVwibG9hZGluZ1wiPkxvYWRpbmcgcmVwb3NpdG9yaWVzLi4uPC9kaXY+JztcbiAgfVxuXG4gIGJpbmRDb2xsZWN0aW9uRXZlbnRzKCkge1xuICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChlKSA9PiB0aGlzLmhhbmRsZVN1Ym1pdChlKSk7XG4gIH1cblxuICBhc3luYyBsb2FkUmVwb3NpdG9yaWVzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZXBvc2l0b3J5U2VsZWN0aW9uKGRhdGEucmVwb3MgfHwge30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJlcnJvclwiPkVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzLiBQbGVhc2UgdHJ5IGFnYWluLjwvZGl2Pic7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyUmVwb3NpdG9yeVNlbGVjdGlvbihyZXBvcykge1xuICAgIGlmICghcmVwb3MgfHwgT2JqZWN0LmtleXMocmVwb3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPVxuICAgICAgICAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj5ObyByZXBvc2l0b3JpZXMgZm91bmQuIEFkZCByZXBvc2l0b3JpZXMgZmlyc3QuPC9kaXY+JztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXBvc0xpc3QgPSBPYmplY3QuZW50cmllcyhyZXBvcylcbiAgICAgIC5zb3J0KChbbmFtZUFdLCBbbmFtZUJdKSA9PiBuYW1lQS5sb2NhbGVDb21wYXJlKG5hbWVCKSlcbiAgICAgIC5tYXAoXG4gICAgICAgIChbbmFtZSwgcmVwb10pID0+IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlcG8tY2hlY2tib3gtaXRlbVwiPlxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInJlcG8tJHtuYW1lfVwiIG5hbWU9XCJyZXBvc1wiIHZhbHVlPVwiJHtuYW1lfVwiPlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZXBvLSR7bmFtZX1cIj5cbiAgICAgICAgICAgIDxzcGFuPiR7bmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlcG8tcGF0aFwiPiR7cmVwby5wYXRofTwvc3Bhbj5cbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICAgIClcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPSByZXBvc0xpc3Q7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRSZXBvcyA9IHRoaXMuZ2V0U2VsZWN0ZWRSZXBvc2l0b3JpZXMoKTtcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cyhuYW1lLCBzZWxlY3RlZFJlcG9zKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZUNvbGxlY3Rpb24obmFtZSwgc2VsZWN0ZWRSZXBvcyk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFwiQ29sbGVjdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseSFcIik7XG4gICAgICBVSU1hbmFnZXIucmVmcmVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGNyZWF0aW5nIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGdldFNlbGVjdGVkUmVwb3NpdG9yaWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKFxuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl06Y2hlY2tlZCcpXG4gICAgKS5tYXAoKGNoZWNrYm94KSA9PiBjaGVja2JveC52YWx1ZSk7XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0cyhuYW1lLCBzZWxlY3RlZFJlcG9zKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBlbnRlciBhIGNvbGxlY3Rpb24gbmFtZVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRSZXBvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgcmVwb3NpdG9yeVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHNhdmVDb2xsZWN0aW9uKG5hbWUsIHNlbGVjdGVkUmVwb3MpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuXG4gICAgaWYgKGRhdGEuY29sbGVjdGlvbnMgJiYgZGF0YS5jb2xsZWN0aW9uc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBjb2xsZWN0aW9uIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIH1cblxuICAgIGlmICghZGF0YS5jb2xsZWN0aW9ucykgZGF0YS5jb2xsZWN0aW9ucyA9IHt9O1xuICAgIGRhdGEuY29sbGVjdGlvbnNbbmFtZV0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVwb3M6IHNlbGVjdGVkUmVwb3MsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLndyaXRlUmVwb3NGaWxlKGRhdGEpO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVSSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgVUlNYW5hZ2VyID0ge1xuICBpbml0KGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgdGhpcy5zZWFyY2hJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoLWlucHV0XCIpO1xuICAgIHRoaXMucmVmcmVzaEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVmcmVzaC1idG5cIik7XG5cbiAgICAvLyBTdG9yZSBjYWxsYmFja3NcbiAgICB0aGlzLmhhbmRsZUVkaXRSZXBvc2l0b3J5ID0gY2FsbGJhY2tzLm9uRWRpdFJlcG9zaXRvcnkgfHwgKCgpID0+IHt9KTtcbiAgICB0aGlzLmhhbmRsZUVkaXRDb2xsZWN0aW9uID0gY2FsbGJhY2tzLm9uRWRpdENvbGxlY3Rpb24gfHwgKCgpID0+IHt9KTtcblxuICAgIC8vIEluaXRpYWxpemUgZWRpdCBjb2xsZWN0aW9uIG1vZGFsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIXRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbCkge1xuICAgICAgdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsID0gbmV3IEVkaXRDb2xsZWN0aW9uTW9kYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfSxcblxuICBiaW5kRXZlbnRzKCkge1xuICAgIC8vIERlYm91bmNlIHNlYXJjaCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG4gICAgY29uc3QgZGVib3VuY2VkVXBkYXRlID0gVXRpbHMuZGVib3VuY2UoKCkgPT4gdGhpcy51cGRhdGVEaXNwbGF5KCksIDMwMCk7XG4gICAgdGhpcy5zZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZGVib3VuY2VkVXBkYXRlKTtcbiAgICB0aGlzLnJlZnJlc2hCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMucmVmcmVzaCgpKTtcbiAgfSxcblxuICBhc3luYyByZWZyZXNoKCkge1xuICAgIHRoaXMuc2hvd1JlZnJlc2hBbmltYXRpb24oKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuICAgICAgdGhpcy5wcm9jZXNzRGF0YShkYXRhKTtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihgRXJyb3IgcmVmcmVzaGluZyBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaGlkZVJlZnJlc2hBbmltYXRpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJvY2Vzc0RhdGEoZGF0YSkge1xuICAgIC8vIFByb2Nlc3MgcmVwb3NpdG9yaWVzXG4gICAgaWYgKGRhdGEucmVwb3MpIHtcbiAgICAgIGNvbnN0IHJlcG9zID0gT2JqZWN0LmVudHJpZXMoZGF0YS5yZXBvcykubWFwKChbbmFtZSwgcmVwb10pID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHBhdGg6IHJlcG8ucGF0aCxcbiAgICAgICAgdXBkYXRlZEF0OiByZXBvLnVwZGF0ZWRBdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KSk7XG4gICAgICBBcHBTdGF0ZS5zZXRSZXBvcyhyZXBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFwcFN0YXRlLnNldFJlcG9zKFtdKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGNvbGxlY3Rpb25zXG4gICAgaWYgKGRhdGEuY29sbGVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb25zID0gT2JqZWN0LnZhbHVlcyhkYXRhLmNvbGxlY3Rpb25zKS5tYXAoKGNvbGxlY3Rpb24pID0+ICh7XG4gICAgICAgIG5hbWU6IGNvbGxlY3Rpb24ubmFtZSxcbiAgICAgICAgcmVwb3M6IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbi5yZXBvcylcbiAgICAgICAgICA/IGNvbGxlY3Rpb24ucmVwb3Muam9pbihcIiwgXCIpXG4gICAgICAgICAgOiBcIlwiLFxuICAgICAgICB1cGRhdGVkQXQ6IGNvbGxlY3Rpb24udXBkYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pKTtcbiAgICAgIEFwcFN0YXRlLnNldENvbGxlY3Rpb25zKGNvbGxlY3Rpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQXBwU3RhdGUuc2V0Q29sbGVjdGlvbnMoW10pO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVEaXNwbGF5KCkge1xuICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRyaW0oKTtcbiAgICB0aGlzLnVwZGF0ZVJlcG9zaXRvcmllc1RhYmxlKEFwcFN0YXRlLmdldEZpbHRlcmVkUmVwb3Moc2VhcmNoVGVybSkpO1xuICAgIHRoaXMudXBkYXRlQ29sbGVjdGlvbnNUYWJsZShBcHBTdGF0ZS5nZXRGaWx0ZXJlZENvbGxlY3Rpb25zKHNlYXJjaFRlcm0pKTtcbiAgfSxcblxuICB1cGRhdGVSZXBvc2l0b3JpZXNUYWJsZShyZXBvcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwb3MtbGlzdFwiKTtcbiAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwb3MtdGFibGVcIik7XG4gICAgY29uc3QgbG9hZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1yZXBvc1wiKTtcblxuICAgIGlmIChyZXBvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvYWRpbmcudGV4dENvbnRlbnQgPSBcIk5vIG1hdGNoaW5nIHJlcG9zaXRvcmllcyBmb3VuZC5cIjtcbiAgICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRhYmxlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB0YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZVwiO1xuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHJlcG9zXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSlcbiAgICAgIC5tYXAoKHJlcG8pID0+IHRoaXMuY3JlYXRlUmVwb3NpdG9yeVJvdyhyZXBvKSlcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5iaW5kUmVwb3NpdG9yeUV2ZW50cygpO1xuICB9LFxuXG4gIGNyZWF0ZVJlcG9zaXRvcnlSb3cocmVwbykge1xuICAgIHJldHVybiBgXG4gICAgICA8dHIgZGF0YS1wYXRoPVwiJHtVdGlscy5mb3JtYXRQYXRoKHJlcG8ucGF0aCl9XCIgZGF0YS1uYW1lPVwiJHtyZXBvLm5hbWV9XCIgY2xhc3M9XCJjbGlja2FibGUtcmVwby1yb3dcIj5cbiAgICAgICAgPHRkPjxzdHJvbmc+JHtyZXBvLm5hbWV9PC9zdHJvbmc+PC90ZD5cbiAgICAgICAgPHRkIGNsYXNzPVwicGF0aFwiPiR7VXRpbHMuZm9ybWF0UGF0aChyZXBvLnBhdGgpfTwvdGQ+XG4gICAgICAgIDx0ZCBjbGFzcz1cImFjdGlvbnNcIj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZ2FwOiA1cHhcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJlZGl0LWJ0blwiIGRhdGEtbmFtZT1cIiR7cmVwby5uYW1lfVwiIGRhdGEtcGF0aD1cIiR7VXRpbHMuZm9ybWF0UGF0aChyZXBvLnBhdGgpfVwiIGRhdGEtdHlwZT1cInJlcG9cIiB0aXRsZT1cIkVkaXQgcmVwb3NpdG9yeVwiPuKcj++4jzwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZS1idG5cIiBkYXRhLW5hbWU9XCIke3JlcG8ubmFtZX1cIiBkYXRhLXR5cGU9XCJyZXBvXCIgdGl0bGU9XCJEZWxldGUgcmVwb3NpdG9yeVwiPvCfl5HvuI88L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgYDtcbiAgfSxcblxuICBiaW5kUmVwb3NpdG9yeUV2ZW50cygpIHtcbiAgICAvLyBCaW5kIGNsaWNrIGV2ZW50cyBmb3Igb3BlbmluZyByZXBvc2l0b3JpZXNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNsaWNrYWJsZS1yZXBvLXJvd1wiKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMuaGFuZGxlUmVwb3NpdG9yeUNsaWNrKGUsIHJvdykpO1xuICAgIH0pO1xuXG4gICAgLy8gQmluZCBlZGl0IGV2ZW50c1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5lZGl0LWJ0bltkYXRhLXR5cGU9XCJyZXBvXCJdJykuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBidG4uZGF0YXNldC5uYW1lO1xuICAgICAgICBjb25zdCBwYXRoID0gYnRuLmRhdGFzZXQucGF0aDtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlRWRpdFJlcG9zaXRvcnkpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVkaXRSZXBvc2l0b3J5KHsgbmFtZSwgcGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGRlbGV0ZSBldmVudHNcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZWxldGUtYnRuW2RhdGEtdHlwZT1cInJlcG9cIl0nKVxuICAgICAgLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PlxuICAgICAgICAgIHRoaXMuaGFuZGxlUmVwb3NpdG9yeURlbGV0ZShlLCBidG4pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgfSxcblxuICBhc3luYyBoYW5kbGVSZXBvc2l0b3J5Q2xpY2soZSwgcm93KSB7XG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQlVUVE9OXCIpIHJldHVybjtcblxuICAgIGNvbnN0IHNlbGVjdGVkSURFID0gSURFTWFuYWdlci5nZXRTZWxlY3RlZElERSgpO1xuICAgIGlmICghc2VsZWN0ZWRJREUpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhbiBJREUgZmlyc3RcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVwb1BhdGggPSByb3cuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYXRoXCIpO1xuICAgIGNvbnN0IHJlcG9OYW1lID0gcm93LmdldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiKTtcbiAgICBjb25zb2xlLmxvZyhyZXBvUGF0aCwgcmVwb05hbWUpO1xuICAgIGlmICghcmVwb1BhdGgpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkub3BlbkluSURFKHtcbiAgICAgICAgbmFtZTogcmVwb05hbWUsXG4gICAgICAgIHBhdGg6IHJlcG9QYXRoLFxuICAgICAgICBpZGU6IHNlbGVjdGVkSURFLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvciB8fCBcIkZhaWxlZCB0byBvcGVuIGluIElERVwiKTtcbiAgICAgIH1cblxuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhcbiAgICAgICAgYFN1Y2Nlc3NmdWxseSBvcGVuZWQgJHtyZXBvUGF0aH0gaW4gJHtzZWxlY3RlZElERX1gXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihgRXJyb3Igb3BlbmluZyBJREU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH0sXG5cbiAgYXN5bmMgaGFuZGxlUmVwb3NpdG9yeURlbGV0ZShlLCBidG4pIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3QgbmFtZSA9IGJ0bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5hbWVcIik7XG4gICAgLy8gaWYgKCFjb25maXJtKGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHJlcG9zaXRvcnkgXCIke25hbWV9XCI/YCkpXG4gICAgLy8gICByZXR1cm47XG5cbiAgICBjb25zdCBsb2FkaW5nRWwgPSB0aGlzLnNob3dMb2FkaW5nSW5kaWNhdG9yKFwiRGVsZXRpbmcuLi5cIik7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmRlbGV0ZVJlcG8obmFtZSk7XG5cbiAgICAgIGlmIChyZXN1bHQ/LnN1Y2Nlc3MpIHtcbiAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhgU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgJHtuYW1lfWApO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQ/LmVycm9yIHx8IFwiVW5rbm93biBlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoYEVycm9yIGRlbGV0aW5nICR7bmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5oaWRlTG9hZGluZ0luZGljYXRvcihsb2FkaW5nRWwpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVDb2xsZWN0aW9uc1RhYmxlKGNvbGxlY3Rpb25zKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb2xsZWN0aW9ucy1saXN0XCIpO1xuICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb2xsZWN0aW9ucy10YWJsZVwiKTtcbiAgICBjb25zdCBsb2FkaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2FkaW5nLWNvbGxlY3Rpb25zXCIpO1xuXG4gICAgaWYgKGNvbGxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9hZGluZy50ZXh0Q29udGVudCA9IFwiTm8gbWF0Y2hpbmcgY29sbGVjdGlvbnMgZm91bmQuXCI7XG4gICAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdGFibGUuc3R5bGUuZGlzcGxheSA9IFwidGFibGVcIjtcblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjb2xsZWN0aW9uc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSkpXG4gICAgICAubWFwKChjb2xsZWN0aW9uKSA9PiB0aGlzLmNyZWF0ZUNvbGxlY3Rpb25Sb3coY29sbGVjdGlvbikpXG4gICAgICAuam9pbihcIlwiKTtcblxuICAgIHRoaXMuYmluZENvbGxlY3Rpb25FdmVudHMoKTtcbiAgfSxcblxuICBjcmVhdGVDb2xsZWN0aW9uUm93KGNvbGxlY3Rpb24pIHtcbiAgICBjb25zdCBjb2xsZWN0aW9uRGF0YSA9IEpTT04uc3RyaW5naWZ5KGNvbGxlY3Rpb24pLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpO1xuICAgIHJldHVybiBgXG4gICAgICA8dHIgY2xhc3M9XCJjbGlja2FibGUtY29sbGVjdGlvbi1yb3dcIiBkYXRhLWNvbGxlY3Rpb249XCIke2NvbGxlY3Rpb25EYXRhfVwiPlxuICAgICAgICA8dGQ+PHN0cm9uZz4ke2NvbGxlY3Rpb24ubmFtZX08L3N0cm9uZz48L3RkPlxuICAgICAgICA8dGQ+JHtjb2xsZWN0aW9uLnJlcG9zfTwvdGQ+XG4gICAgICAgIDx0ZCBjbGFzcz1cImFjdGlvbnNcIj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZ2FwOiA1cHhcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJlZGl0LWJ0blwiIGRhdGEtbmFtZT1cIiR7Y29sbGVjdGlvbi5uYW1lfVwiIGRhdGEtdHlwZT1cImNvbGxlY3Rpb25cIiB0aXRsZT1cIkVkaXQgY29sbGVjdGlvblwiPuKcj++4jzwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZS1idG5cIiBkYXRhLW5hbWU9XCIke2NvbGxlY3Rpb24ubmFtZX1cIiBkYXRhLXR5cGU9XCJjb2xsZWN0aW9uXCIgdGl0bGU9XCJEZWxldGUgY29sbGVjdGlvblwiPvCfl5HvuI88L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgYDtcbiAgfSxcblxuICBiaW5kQ29sbGVjdGlvbkV2ZW50cygpIHtcbiAgICAvLyBCaW5kIGNsaWNrIGV2ZW50cyBmb3Igb3BlbmluZyBjb2xsZWN0aW9uc1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2xpY2thYmxlLWNvbGxlY3Rpb24tcm93XCIpLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgcm93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4gdGhpcy5oYW5kbGVDb2xsZWN0aW9uQ2xpY2soZSwgcm93KSk7XG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGVkaXQgZXZlbnRzXG4gICAgZG9jdW1lbnRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcuZWRpdC1idG5bZGF0YS10eXBlPVwiY29sbGVjdGlvblwiXScpXG4gICAgICAuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25EYXRhID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgIGJ0blxuICAgICAgICAgICAgICAuY2xvc2VzdChcInRyXCIpXG4gICAgICAgICAgICAgIC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbGxlY3Rpb25cIilcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsLm9wZW4oY29sbGVjdGlvbkRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIEJpbmQgZGVsZXRlIGV2ZW50c1xuICAgIGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLmRlbGV0ZS1idG5bZGF0YS10eXBlPVwiY29sbGVjdGlvblwiXScpXG4gICAgICAuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+XG4gICAgICAgICAgdGhpcy5oYW5kbGVDb2xsZWN0aW9uRGVsZXRlKGUsIGJ0bilcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9LFxuXG4gIGFzeW5jIGhhbmRsZUNvbGxlY3Rpb25DbGljayhlLCByb3cpIHtcbiAgICBpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJCVVRUT05cIikgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBKU09OLnBhcnNlKHJvdy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbGxlY3Rpb25cIikpO1xuICAgICAgY29uc3QgcmVwb3NEYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuXG4gICAgICBjb25zdCByZXBvcyA9IGNvbGxlY3Rpb24ucmVwb3Muc3BsaXQoXCIsXCIpLm1hcCgocmVwbykgPT4ge1xuICAgICAgICBjb25zdCBbbmFtZSwgcGF0aCwgaWRlXSA9IHJlcG9cbiAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgLnNwbGl0KFwifFwiKVxuICAgICAgICAgIC5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgcGF0aCwgaWRlIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gT3BlbiBhbGwgcmVwb3NpdG9yaWVzIGluIHBhcmFsbGVsXG4gICAgICBjb25zdCBwcm9taXNlcyA9IHJlcG9zLm1hcChhc3luYyAocmVwbykgPT4ge1xuICAgICAgICBjb25zdCByZXBvRGF0YSA9IHJlcG9zRGF0YS5yZXBvc1tyZXBvLm5hbWVdO1xuXG4gICAgICAgIGlmICghcmVwb0RhdGEpIHtcbiAgICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgICAgIGAke3JlcG8ubmFtZX06IE5vdCBmb3VuZCBpbiByZXBvc2l0b3JpZXNgXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZGUgPSByZXBvLmlkZSB8fCBJREVNYW5hZ2VyLmdldFNlbGVjdGVkSURFKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkub3BlbkluSURFKHtcbiAgICAgICAgICAgIG5hbWU6IHJlcG8ubmFtZSxcbiAgICAgICAgICAgIHBhdGg6IHJlcG9EYXRhLnBhdGgsXG4gICAgICAgICAgICBpZGU6IGlkZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gb3BlbiAke3JlcG8ubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKGBTdWNjZXNzZnVsbHkgb3BlbmVkICR7Y29sbGVjdGlvbi5uYW1lfWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgY29sbGVjdGlvbjogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIGhhbmRsZUNvbGxlY3Rpb25EZWxldGUoZSwgYnRuKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IG5hbWUgPSBidG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIpO1xuICAgIC8vIGlmICghY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSBjb2xsZWN0aW9uIFwiJHtuYW1lfVwiP2ApKVxuICAgIC8vICAgcmV0dXJuO1xuXG4gICAgY29uc3QgbG9hZGluZ0VsID0gdGhpcy5zaG93TG9hZGluZ0luZGljYXRvcihcIkRlbGV0aW5nLi4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5kZWxldGVDb2xsZWN0aW9uKG5hbWUpO1xuXG4gICAgICBpZiAocmVzdWx0Py5zdWNjZXNzKSB7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Py5lcnJvciB8fCBcIlVua25vd24gZXJyb3JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKGBFcnJvciBkZWxldGluZyAke25hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmdJbmRpY2F0b3IobG9hZGluZ0VsKTtcbiAgICB9XG4gIH0sXG5cbiAgc2hvd1JlZnJlc2hBbmltYXRpb24oKSB7XG4gICAgdGhpcy5yZWZyZXNoQnRuLmNsYXNzTGlzdC5hZGQoXCJyb3RhdGluZ1wiKTtcbiAgfSxcblxuICBoaWRlUmVmcmVzaEFuaW1hdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVmcmVzaEJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwicm90YXRpbmdcIik7XG4gICAgfSwgMTAwMCk7XG4gIH0sXG5cbiAgc2hvd0xvYWRpbmdJbmRpY2F0b3IodGV4dCkge1xuICAgIGNvbnN0IGluZGljYXRvciA9IFV0aWxzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdHlsZTogYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC43KTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgICBgLFxuICAgICAgfSxcbiAgICAgIFt0ZXh0XVxuICAgICk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluZGljYXRvcik7XG4gICAgcmV0dXJuIGluZGljYXRvcjtcbiAgfSxcblxuICBoaWRlTG9hZGluZ0luZGljYXRvcihpbmRpY2F0b3IpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhpbmRpY2F0b3IpKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGluZGljYXRvcik7XG4gICAgfVxuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEFwcGxpY2F0aW9uIEluaXRpYWxpemF0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgQXBwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIEluaXRpYWxpemUgY29yZSBzeXN0ZW1zXG4gICAgVGhlbWVNYW5hZ2VyLmluaXQoKTtcbiAgICBJREVNYW5hZ2VyLmluaXQoKTtcblxuICAgIC8vIEluaXRpYWxpemUgbW9kYWxzXG4gICAgdGhpcy5yZXBvc2l0b3J5TW9kYWwgPSBuZXcgUmVwb3NpdG9yeU1vZGFsKCk7XG4gICAgdGhpcy5lZGl0UmVwb3NpdG9yeU1vZGFsID0gbmV3IEVkaXRSZXBvc2l0b3J5TW9kYWwoKTtcbiAgICB0aGlzLmNvbGxlY3Rpb25Nb2RhbCA9IG5ldyBDb2xsZWN0aW9uTW9kYWwoKTtcbiAgICB0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwgPSBuZXcgRWRpdENvbGxlY3Rpb25Nb2RhbCgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBVSSBtYW5hZ2VyIHdpdGggbW9kYWxzXG4gICAgVUlNYW5hZ2VyLmluaXQoe1xuICAgICAgb25FZGl0UmVwb3NpdG9yeTogKHJlcG8pID0+IHRoaXMuZWRpdFJlcG9zaXRvcnlNb2RhbC5vcGVuKHJlcG8pLFxuICAgICAgb25FZGl0Q29sbGVjdGlvbjogKGNvbGxlY3Rpb24pID0+XG4gICAgICAgIHRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbC5vcGVuKGNvbGxlY3Rpb24pLFxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGVsZWN0cm9uIEFQSSBkYXRhXG4gICAgdGhpcy5iaW5kRWxlY3Ryb25FdmVudHMoKTtcblxuICAgIGNvbnNvbGUubG9nKFwi8J+RiyBPcGVuTWF0ZSBhcHBsaWNhdGlvbiBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcIik7XG4gIH1cblxuICBiaW5kRWxlY3Ryb25FdmVudHMoKSB7XG4gICAgaWYgKHdpbmRvdy5lbGVjdHJvbkFQSSAmJiB3aW5kb3cuZWxlY3Ryb25BUEkub25SZXBvc0RhdGEpIHtcbiAgICAgIHdpbmRvdy5lbGVjdHJvbkFQSS5vblJlcG9zRGF0YSgoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcG9zID0gW10sIGNvbGxlY3Rpb25zID0gW10gfSA9IGRhdGE7XG4gICAgICAgIEFwcFN0YXRlLnNldFJlcG9zKHJlcG9zKTtcbiAgICAgICAgQXBwU3RhdGUuc2V0Q29sbGVjdGlvbnMoY29sbGVjdGlvbnMpO1xuICAgICAgICBVSU1hbmFnZXIudXBkYXRlRGlzcGxheSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJbml0aWFsaXplIEFwcGxpY2F0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICBuZXcgQXBwKCk7XG59KTtcblxuLy8gSW1wb3J0IHN0eWxlc1xuaW1wb3J0IFwiLi9pbmRleC5jc3NcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/renderer.js\n\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("2c8dd495d27cff02848b")
/******/ })();
/******/ 
/******/ }
);