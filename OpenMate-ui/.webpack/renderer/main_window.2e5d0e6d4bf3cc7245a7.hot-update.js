"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateopenmate_ui"]("main_window",{

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n// =======================\n// State Management\n// =======================\nconst AppState = {\n  repos: [],\n  collections: [],\n\n  setRepos(repos) {\n    this.repos = repos;\n  },\n\n  setCollections(collections) {\n    this.collections = collections;\n  },\n\n  getFilteredRepos(searchTerm) {\n    return this.filterItems(this.repos, searchTerm);\n  },\n\n  getFilteredCollections(searchTerm) {\n    return this.filterItems(this.collections, searchTerm);\n  },\n\n  filterItems(items, searchTerm) {\n    if (!searchTerm) return items;\n    const term = searchTerm.toLowerCase();\n    return items.filter(\n      (item) =>\n        item.name.toLowerCase().includes(term) ||\n        (item.path && item.path.toLowerCase().includes(term)) ||\n        (item.repos && item.repos.toLowerCase().includes(term))\n    );\n  },\n};\n\n// =======================\n// Utility Functions\n// =======================\nconst Utils = {\n  formatPath(path) {\n    return path ? path.replace(/\\\\/g, \"/\") : \"\";\n  },\n\n  debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  },\n\n  createElement(tag, attributes = {}, children = []) {\n    const element = document.createElement(tag);\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (key === \"className\") {\n        element.className = value;\n      } else {\n        element.setAttribute(key, value);\n      }\n    });\n    children.forEach((child) => {\n      if (typeof child === \"string\") {\n        element.appendChild(document.createTextNode(child));\n      } else {\n        element.appendChild(child);\n      }\n    });\n    return element;\n  },\n};\n\n// =======================\n// Storage Management\n// =======================\nconst Storage = {\n  THEME_KEY: \"openmate-theme\",\n  IDE_KEY: \"openmate-ide-selector\",\n\n  get(key) {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      console.warn(\"Storage get failed:\", e);\n      return null;\n    }\n  },\n\n  set(key, value) {\n    try {\n      localStorage.setItem(key, value);\n    } catch (e) {\n      console.warn(\"Storage set failed:\", e);\n    }\n  },\n};\n\n// =======================\n// Theme Management\n// =======================\nconst ThemeManager = {\n  init() {\n    this.themeToggle = document.getElementById(\"theme-toggle\");\n    this.themeIcon = document.querySelector(\".theme-icon\");\n\n    this.loadTheme();\n    this.bindEvents();\n  },\n\n  loadTheme() {\n    const savedTheme = Storage.get(Storage.THEME_KEY);\n    const systemPrefersDark = window.matchMedia(\n      \"(prefers-color-scheme: dark)\"\n    ).matches;\n    const theme = savedTheme || (systemPrefersDark ? \"dark\" : \"light\");\n\n    this.setTheme(theme);\n  },\n\n  setTheme(theme) {\n    document.documentElement.setAttribute(\"data-theme\", theme);\n    this.themeIcon.textContent = theme === \"dark\" ? \"☀️\" : \"🌙\";\n    Storage.set(Storage.THEME_KEY, theme);\n  },\n\n  toggle() {\n    const currentTheme = document.documentElement.getAttribute(\"data-theme\");\n    const newTheme = currentTheme === \"dark\" ? \"light\" : \"dark\";\n    this.setTheme(newTheme);\n  },\n\n  bindEvents() {\n    this.themeToggle.addEventListener(\"click\", () => this.toggle());\n  },\n};\n\n// =======================\n// IDE Selector Management\n// =======================\nconst IDEManager = {\n  init() {\n    this.selector = document.getElementById(\"ide-selector\");\n    this.loadPreference();\n    this.bindEvents();\n  },\n\n  loadPreference() {\n    const savedIDE = Storage.get(Storage.IDE_KEY);\n    if (savedIDE) {\n      this.selector.value = savedIDE;\n    }\n  },\n\n  getSelectedIDE() {\n    return this.selector.value;\n  },\n\n  bindEvents() {\n    this.selector.addEventListener(\"change\", (e) => {\n      const selectedIDE = e.target.value;\n      if (selectedIDE) {\n        Storage.set(Storage.IDE_KEY, selectedIDE);\n        NotificationManager.showSuccess(`Default IDE set to ${selectedIDE}`);\n      }\n    });\n  },\n};\n\n// =======================\n// Notification Management\n// =======================\nconst NotificationManager = {\n  show(message, type = \"info\", duration = 3000) {\n    const colors = {\n      success: \"#4CAF50\",\n      error: \"#F44336\",\n      info: \"#2196F3\",\n    };\n\n    const notification = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        bottom: 20px;\n        right: 20px;\n        padding: 10px 20px;\n        background: ${colors[type]};\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n        transition: opacity 0.3s ease;\n      `,\n      },\n      [message]\n    );\n\n    document.body.appendChild(notification);\n\n    setTimeout(() => {\n      notification.style.opacity = \"0\";\n      setTimeout(() => {\n        if (document.body.contains(notification)) {\n          document.body.removeChild(notification);\n        }\n      }, 300);\n    }, duration);\n  },\n\n  showSuccess(message) {\n    this.show(message, \"success\");\n  },\n\n  showError(message) {\n    this.show(message, \"error\");\n  },\n\n  showInfo(message) {\n    this.show(message, \"info\");\n  },\n};\n\n// =======================\n// Modal Management\n// =======================\nclass Modal {\n  constructor(modalId, formId, openBtnId) {\n    this.modal = document.getElementById(modalId);\n    this.form = document.getElementById(formId);\n    this.openBtn = document.getElementById(openBtnId);\n    this.closeBtn = this.modal.querySelector(\".close\");\n\n    this.bindEvents();\n  }\n\n  bindEvents() {\n    this.openBtn?.addEventListener(\"click\", () => this.open());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n\n    // Close on outside click\n    window.addEventListener(\"click\", (e) => {\n      if (e.target === this.modal) {\n        this.close();\n      }\n    });\n\n    // Close on Escape key\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Escape\" && this.isOpen()) {\n        this.close();\n      }\n    });\n  }\n\n  open() {\n    this.modal.style.display = \"flex\";\n    document.body.style.overflow = \"hidden\";\n    this.onOpen();\n  }\n\n  close() {\n    this.modal.style.display = \"none\";\n    document.body.style.overflow = \"auto\";\n    this.form?.reset();\n    this.onClose();\n  }\n\n  isOpen() {\n    return this.modal.style.display === \"flex\";\n  }\n\n  onOpen() {\n    // Override in subclasses\n  }\n\n  onClose() {\n    // Override in subclasses\n  }\n}\n\n// =======================\n// Repository Modal\n// =======================\nclass RepositoryModal extends Modal {\n  constructor() {\n    super(\"add-repo-modal\", \"add-repo-form\", \"add-repo-btn\");\n    this.nameInput = document.getElementById(\"repo-name\");\n    this.pathInput = document.getElementById(\"repo-path\");\n    this.browseBtn = document.getElementById(\"browse-path\");\n\n    this.bindRepositoryEvents();\n  }\n\n  onOpen() {\n    this.nameInput.focus();\n  }\n\n  bindRepositoryEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn.addEventListener(\"click\", () => this.browsePath());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const path = this.pathInput.value.trim();\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      await window.electronAPI.addRepository({ name, path });\n      this.close();\n      NotificationManager.showSuccess(\"Repository added successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error adding repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name || !path) {\n      NotificationManager.showError(\"Please fill in all fields\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Repository Modal\n// =======================\nclass EditRepositoryModal extends Modal {\n  constructor() {\n    super(\"edit-repo-modal\", \"edit-repo-form\");\n    this.nameInput = document.getElementById(\"edit-repo-name\");\n    this.pathInput = document.getElementById(\"edit-repo-path\");\n    this.originalNameInput = document.getElementById(\"edit-original-name\");\n    this.browseBtn = document.getElementById(\"edit-browse-path\");\n    this.closeBtn = document.querySelector(\"#edit-repo-modal .close\");\n\n    this.bindEvents();\n  }\n\n  open(repo) {\n    // Store original values\n    this.originalNameInput.value = repo.name;\n\n    // Set current values (read-only)\n    document.getElementById(\"current-repo-name\").textContent = repo.name;\n    document.getElementById(\"current-repo-path\").textContent = repo.path;\n\n    // Clear and reset form fields\n    this.nameInput.value = repo.name;\n    this.pathInput.value = repo.path;\n    this.nameInput.placeholder = `Current: ${repo.name}`;\n    this.pathInput.placeholder = `Current: ${repo.path}`;\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n    this.browseBtn?.addEventListener(\"click\", () => this.browsePath());\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim() || originalName; // Use original name if new name is empty\n    const path =\n      this.pathInput.value.trim() ||\n      this.pathInput.placeholder.replace(\"Current: \", \"\"); // Use current path if empty\n\n    if (!this.validateInputs(name, path)) return;\n\n    try {\n      // Get current repositories data\n      const data = await window.electronAPI.getReposData();\n\n      // Ensure we have the expected data structure\n      if (!data || typeof data !== \"object\" || !data.repos) {\n        throw new Error(\"Invalid repository data structure\");\n      }\n\n      console.log(\"Current repositories:\", data.repos); // Debug log\n      console.log(\"Looking for repository with name:\", originalName); // Debug log\n\n      // Check if the repository exists\n      if (!data.repos[originalName]) {\n        console.error(\"Repository not found in:\", data.repos);\n        throw new Error(\"Repository not found\");\n      }\n\n      // Check if name is being changed to an existing one (except current repo)\n      if (name !== originalName && data.repos[name]) {\n        NotificationManager.showError(\n          \"A repository with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the repositories\n      const updatedRepos = { ...data.repos };\n\n      // If name changed, remove old entry\n      if (name !== originalName) {\n        delete updatedRepos[originalName];\n      }\n\n      // Update or add the repository with new values and updatedAt timestamp\n      const now = new Date().toISOString();\n      updatedRepos[name] = {\n        path,\n        updatedAt: data.repos[originalName]?.updatedAt || now,\n      };\n\n      // Save the updated repositories using the correct IPC method\n      await window.electronAPI.writeReposFile({\n        ...data,\n        repos: updatedRepos,\n      });\n\n      // Refresh UI\n      UIManager.refresh();\n\n      NotificationManager.showSuccess(\"Repository updated successfully\");\n      this.close();\n    } catch (error) {\n      console.error(\"Error updating repository:\", error);\n      NotificationManager.showError(\n        `Failed to update repository: ${error.message}`\n      );\n    }\n  }\n\n  validateInputs(name, path) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a repository name\");\n      return false;\n    }\n    if (!path) {\n      NotificationManager.showError(\"Please select a repository path\");\n      return false;\n    }\n    return true;\n  }\n\n  async browsePath() {\n    try {\n      const path = await window.electronAPI.openDirectoryDialog();\n      if (path) {\n        this.pathInput.value = path;\n      }\n    } catch (error) {\n      NotificationManager.showError(\n        `Error selecting directory: ${error.message}`\n      );\n    }\n  }\n}\n\n// =======================\n// Edit Collection Modal\n// =======================\nclass EditCollectionModal extends Modal {\n  constructor() {\n    super(\"edit-collection-modal\", \"edit-collection-form\");\n    this.nameInput = document.getElementById(\"edit-collection-name\");\n    this.originalNameInput = document.getElementById(\n      \"edit-original-collection-name\"\n    );\n    this.currentNameEl = document.getElementById(\"current-collection-name\");\n    this.currentReposEl = document.getElementById(\"current-collection-repos\");\n    this.reposSelection = document.getElementById(\"edit-repos-selection\");\n    this.closeBtn = document.querySelector(\"#edit-collection-modal .close\");\n\n    this.bindEvents();\n  }\n\n  async open(collection) {\n    // Store original values\n    this.originalNameInput.value = collection.name;\n\n    // Set current values\n    this.currentNameEl.textContent = collection.name;\n\n    // Handle both array and string formats for backward compatibility\n    const repoList = Array.isArray(collection.repos)\n      ? collection.repos\n      : (collection.repos || \"\")\n          .split(\",\")\n          .map((s) => s.trim())\n          .filter(Boolean);\n\n    this.currentReposEl.textContent = repoList.length\n      ? repoList.join(\", \")\n      : \"No repositories\";\n    this.nameInput.value = collection.name;\n    this.nameInput.placeholder = `Current: ${collection.name}`;\n\n    // Load repositories with current selection\n    await this.loadRepositories(repoList);\n\n    // Open modal and focus\n    super.open();\n    this.nameInput.focus();\n  }\n\n  bindEvents() {\n    this.form?.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n\n    this.closeBtn?.addEventListener(\"click\", () => this.close());\n  }\n\n  async loadRepositories(selectedRepos = []) {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {}, selectedRepos);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos, selectedRepos = []) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"edit-repo-${name}\" name=\"repos\" value=\"${name}\" \n                 ${selectedRepos.includes(name) ? \"checked\" : \"\"}>\n          <label for=\"edit-repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const originalName = this.originalNameInput.value;\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      const data = await window.electronAPI.getReposData();\n\n      // Check if name is being changed to an existing one (except current collection)\n      if (name !== originalName && data.collections && data.collections[name]) {\n        NotificationManager.showError(\n          \"A collection with this name already exists\"\n        );\n        return;\n      }\n\n      // Create a copy of the collections\n      const updatedCollections = { ...data.collections };\n\n      // Remove old entry if name changed\n      if (name !== originalName) {\n        delete updatedCollections[originalName];\n      }\n\n      // Update or add the collection with new values\n      updatedCollections[name] = {\n        name,\n        repos: selectedRepos, // Save as array\n        updatedAt:\n          updatedCollections[originalName]?.updatedAt ||\n          new Date().toISOString(),\n      };\n\n      // Save the updated collections\n      await window.electronAPI.writeReposFile({\n        ...data,\n        collections: updatedCollections,\n      });\n\n      this.close();\n      NotificationManager.showSuccess(\"Collection updated successfully\");\n      UIManager.refresh();\n    } catch (error) {\n      console.error(\"Error updating collection:\", error);\n      NotificationManager.showError(\n        `Failed to update collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// =======================\n// Collection Modal\n// =======================\nclass CollectionModal extends Modal {\n  constructor() {\n    super(\"add-collection-modal\", \"add-collection-form\", \"add-collection-btn\");\n    this.nameInput = document.getElementById(\"collection-name\");\n    this.reposSelection = document.getElementById(\"repos-selection\");\n\n    this.bindCollectionEvents();\n  }\n\n  async onOpen() {\n    this.nameInput.focus();\n    await this.loadRepositories();\n  }\n\n  onClose() {\n    this.reposSelection.innerHTML =\n      '<div class=\"loading\">Loading repositories...</div>';\n  }\n\n  bindCollectionEvents() {\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\n  }\n\n  async loadRepositories() {\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.renderRepositorySelection(data.repos || {});\n    } catch (error) {\n      NotificationManager.showError(\n        `Error loading repositories: ${error.message}`\n      );\n      this.reposSelection.innerHTML =\n        '<div class=\"error\">Error loading repositories. Please try again.</div>';\n    }\n  }\n\n  renderRepositorySelection(repos) {\n    if (!repos || Object.keys(repos).length === 0) {\n      this.reposSelection.innerHTML =\n        '<div class=\"loading\">No repositories found. Add repositories first.</div>';\n      return;\n    }\n\n    const reposList = Object.entries(repos)\n      .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n      .map(\n        ([name, repo]) => `\n        <div class=\"repo-checkbox-item\">\n          <input type=\"checkbox\" id=\"repo-${name}\" name=\"repos\" value=\"${name}\">\n          <label for=\"repo-${name}\">\n            <span>${name}</span>\n            <span class=\"repo-path\">${repo.path}</span>\n          </label>\n        </div>\n      `\n      )\n      .join(\"\");\n\n    this.reposSelection.innerHTML = reposList;\n  }\n\n  async handleSubmit(e) {\n    e.preventDefault();\n\n    const name = this.nameInput.value.trim();\n    const selectedRepos = this.getSelectedRepositories();\n\n    if (!this.validateInputs(name, selectedRepos)) return;\n\n    try {\n      await this.saveCollection(name, selectedRepos);\n      this.close();\n      NotificationManager.showSuccess(\"Collection created successfully!\");\n      UIManager.refresh();\n    } catch (error) {\n      NotificationManager.showError(\n        `Error creating collection: ${error.message}`\n      );\n    }\n  }\n\n  getSelectedRepositories() {\n    return Array.from(\n      this.reposSelection.querySelectorAll('input[type=\"checkbox\"]:checked')\n    ).map((checkbox) => checkbox.value);\n  }\n\n  validateInputs(name, selectedRepos) {\n    if (!name) {\n      NotificationManager.showError(\"Please enter a collection name\");\n      return false;\n    }\n\n    if (selectedRepos.length === 0) {\n      NotificationManager.showError(\"Please select at least one repository\");\n      return false;\n    }\n\n    return true;\n  }\n\n  async saveCollection(name, selectedRepos) {\n    const data = await window.electronAPI.getReposData();\n\n    if (data.collections && data.collections[name]) {\n      throw new Error(\"A collection with this name already exists\");\n    }\n\n    if (!data.collections) data.collections = {};\n    data.collections[name] = {\n      name,\n      repos: selectedRepos,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await window.electronAPI.writeReposFile(data);\n  }\n}\n\n// =======================\n// UI Management\n// =======================\nconst UIManager = {\n  init(callbacks = {}) {\n    this.searchInput = document.getElementById(\"search-input\");\n    this.refreshBtn = document.getElementById(\"refresh-btn\");\n\n    // Store callbacks\n    this.handleEditRepository = callbacks.onEditRepository || (() => {});\n    this.handleEditCollection = callbacks.onEditCollection || (() => {});\n\n    // Initialize edit collection modal if it doesn't exist\n    if (!this.editCollectionModal) {\n      this.editCollectionModal = new EditCollectionModal();\n    }\n\n    this.bindEvents();\n    this.refresh();\n  },\n\n  bindEvents() {\n    // Debounce search to improve performance\n    const debouncedUpdate = Utils.debounce(() => this.updateDisplay(), 300);\n    this.searchInput.addEventListener(\"input\", debouncedUpdate);\n    this.refreshBtn.addEventListener(\"click\", () => this.refresh());\n  },\n\n  async refresh() {\n    this.showRefreshAnimation();\n\n    try {\n      const data = await window.electronAPI.getReposData();\n      this.processData(data);\n      this.updateDisplay();\n    } catch (error) {\n      NotificationManager.showError(`Error refreshing data: ${error.message}`);\n    } finally {\n      this.hideRefreshAnimation();\n    }\n  },\n\n  processData(data) {\n    // Process repositories\n    if (data.repos) {\n      const repos = Object.entries(data.repos).map(([name, repo]) => ({\n        name,\n        path: repo.path,\n        updatedAt: repo.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setRepos(repos);\n    } else {\n      AppState.setRepos([]);\n    }\n\n    // Process collections\n    if (data.collections) {\n      const collections = Object.values(data.collections).map((collection) => ({\n        name: collection.name,\n        repos: Array.isArray(collection.repos)\n          ? collection.repos.join(\", \")\n          : \"\",\n        updatedAt: collection.updatedAt || new Date().toISOString(),\n      }));\n      AppState.setCollections(collections);\n    } else {\n      AppState.setCollections([]);\n    }\n  },\n\n  updateDisplay() {\n    const searchTerm = this.searchInput.value.trim();\n    this.updateRepositoriesTable(AppState.getFilteredRepos(searchTerm));\n    this.updateCollectionsTable(AppState.getFilteredCollections(searchTerm));\n  },\n\n  updateRepositoriesTable(repos) {\n    const container = document.getElementById(\"repos-list\");\n    const table = document.getElementById(\"repos-table\");\n    const loading = document.getElementById(\"loading-repos\");\n\n    if (repos.length === 0) {\n      loading.textContent = \"No matching repositories found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = repos\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((repo) => this.createRepositoryRow(repo))\n      .join(\"\");\n\n    this.bindRepositoryEvents();\n  },\n\n  createRepositoryRow(repo) {\n    return `\n      <tr data-path=\"${Utils.formatPath(repo.path)}\" class=\"clickable-repo-row\">\n        <td><strong>${repo.name}</strong></td>\n        <td class=\"path\">${Utils.formatPath(repo.path)}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${repo.name}\" data-path=\"${Utils.formatPath(repo.path)}\" data-type=\"repo\" title=\"Edit repository\">✏️</button>\n            <button class=\"delete-btn\" data-name=\"${repo.name}\" data-type=\"repo\" title=\"Delete repository\">🗑️</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindRepositoryEvents() {\n    // Bind click events for opening repositories\n    document.querySelectorAll(\".clickable-repo-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleRepositoryClick(e, row));\n    });\n\n    // Bind edit events\n    document.querySelectorAll('.edit-btn[data-type=\"repo\"]').forEach((btn) => {\n      btn.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        const name = btn.dataset.name;\n        const path = btn.dataset.path;\n        if (this.handleEditRepository) {\n          this.handleEditRepository({ name, path });\n        }\n      });\n    });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"repo\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleRepositoryDelete(e, btn)\n        );\n      });\n  },\n\n  async handleRepositoryClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    const selectedIDE = IDEManager.getSelectedIDE();\n    if (!selectedIDE) {\n      NotificationManager.showError(\"Please select an IDE first\");\n      return;\n    }\n\n    const repoPath = row.getAttribute(\"data-path\");\n    const repoName = row.getAttribute(\"data-name\");\n    console.log(repoPath, repoName);\n    if (!repoPath) return;\n\n    try {\n      const result = await window.electronAPI.openInIDE({\n        name: row.getAttribute(\"data-name\"),\n        path: repoPath,\n        ide: selectedIDE,\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || \"Failed to open in IDE\");\n      }\n\n      NotificationManager.showSuccess(\n        `Successfully opened ${repoPath} in ${selectedIDE}`\n      );\n    } catch (error) {\n      NotificationManager.showError(`Error opening IDE: ${error.message}`);\n    }\n  },\n\n  async handleRepositoryDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete repository \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteRepo(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  updateCollectionsTable(collections) {\n    const container = document.getElementById(\"collections-list\");\n    const table = document.getElementById(\"collections-table\");\n    const loading = document.getElementById(\"loading-collections\");\n\n    if (collections.length === 0) {\n      loading.textContent = \"No matching collections found.\";\n      loading.style.display = \"block\";\n      table.style.display = \"none\";\n      return;\n    }\n\n    loading.style.display = \"none\";\n    table.style.display = \"table\";\n\n    container.innerHTML = collections\n      .sort((a, b) => a.name.localeCompare(b.name))\n      .map((collection) => this.createCollectionRow(collection))\n      .join(\"\");\n\n    this.bindCollectionEvents();\n  },\n\n  createCollectionRow(collection) {\n    const collectionData = JSON.stringify(collection).replace(/\"/g, \"&quot;\");\n    return `\n      <tr class=\"clickable-collection-row\" data-collection=\"${collectionData}\">\n        <td><strong>${collection.name}</strong></td>\n        <td>${collection.repos}</td>\n        <td class=\"actions\">\n          <div style=\"display: flex; gap: 5px\">\n            <button class=\"edit-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Edit collection\">✏️</button>\n            <button class=\"delete-btn\" data-name=\"${collection.name}\" data-type=\"collection\" title=\"Delete collection\">🗑️</button>\n          </div>\n        </td>\n      </tr>\n    `;\n  },\n\n  bindCollectionEvents() {\n    // Bind click events for opening collections\n    document.querySelectorAll(\".clickable-collection-row\").forEach((row) => {\n      row.addEventListener(\"click\", (e) => this.handleCollectionClick(e, row));\n    });\n\n    // Bind edit events\n    document\n      .querySelectorAll('.edit-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          const collectionData = JSON.parse(\n            btn\n              .closest(\"tr\")\n              .getAttribute(\"data-collection\")\n              .replace(/&quot;/g, '\"')\n          );\n          if (this.editCollectionModal) {\n            this.editCollectionModal.open(collectionData);\n          }\n        });\n      });\n\n    // Bind delete events\n    document\n      .querySelectorAll('.delete-btn[data-type=\"collection\"]')\n      .forEach((btn) => {\n        btn.addEventListener(\"click\", (e) =>\n          this.handleCollectionDelete(e, btn)\n        );\n      });\n  },\n\n  async handleCollectionClick(e, row) {\n    if (e.target.tagName === \"BUTTON\") return;\n\n    try {\n      const collection = JSON.parse(row.getAttribute(\"data-collection\"));\n      const reposData = await window.electronAPI.getReposData();\n\n      const repos = collection.repos.split(\",\").map((repo) => {\n        const [name, path, ide] = repo\n          .trim()\n          .split(\"|\")\n          .map((s) => s.trim());\n        return { name, path, ide };\n      });\n\n      // Open all repositories in parallel\n      const promises = repos.map(async (repo) => {\n        const repoData = reposData.repos[repo.name];\n\n        if (!repoData) {\n          NotificationManager.showError(\n            `${repo.name}: Not found in repositories`\n          );\n          return;\n        }\n\n        const ide = repo.ide || IDEManager.getSelectedIDE();\n\n        try {\n          await window.electronAPI.openInIDE({\n            name: repo.name,\n            path: repoData.path,\n            ide: ide,\n          });\n        } catch (error) {\n          NotificationManager.showError(\n            `Failed to open ${repo.name}: ${error.message}`\n          );\n        }\n      });\n\n      await Promise.allSettled(promises);\n      NotificationManager.showSuccess(`Successfully opened ${collection.name}`);\n    } catch (error) {\n      NotificationManager.showError(\n        `Error processing collection: ${error.message}`\n      );\n    }\n  },\n\n  async handleCollectionDelete(e, btn) {\n    e.stopPropagation();\n\n    const name = btn.getAttribute(\"data-name\");\n    // if (!confirm(`Are you sure you want to delete collection \"${name}\"?`))\n    //   return;\n\n    const loadingEl = this.showLoadingIndicator(\"Deleting...\");\n\n    try {\n      const result = await window.electronAPI.deleteCollection(name);\n\n      if (result?.success) {\n        NotificationManager.showSuccess(`Successfully deleted ${name}`);\n        this.updateDisplay();\n      } else {\n        throw new Error(result?.error || \"Unknown error\");\n      }\n    } catch (error) {\n      NotificationManager.showError(`Error deleting ${name}: ${error.message}`);\n    } finally {\n      this.hideLoadingIndicator(loadingEl);\n    }\n  },\n\n  showRefreshAnimation() {\n    this.refreshBtn.classList.add(\"rotating\");\n  },\n\n  hideRefreshAnimation() {\n    setTimeout(() => {\n      this.refreshBtn.classList.remove(\"rotating\");\n    }, 1000);\n  },\n\n  showLoadingIndicator(text) {\n    const indicator = Utils.createElement(\n      \"div\",\n      {\n        style: `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        padding: 10px;\n        background: rgba(0,0,0,0.7);\n        color: white;\n        border-radius: 4px;\n        z-index: 1000;\n      `,\n      },\n      [text]\n    );\n\n    document.body.appendChild(indicator);\n    return indicator;\n  },\n\n  hideLoadingIndicator(indicator) {\n    if (document.body.contains(indicator)) {\n      document.body.removeChild(indicator);\n    }\n  },\n};\n\n// =======================\n// Application Initialization\n// =======================\nclass App {\n  constructor() {\n    this.init();\n  }\n\n  init() {\n    // Initialize core systems\n    ThemeManager.init();\n    IDEManager.init();\n\n    // Initialize modals\n    this.repositoryModal = new RepositoryModal();\n    this.editRepositoryModal = new EditRepositoryModal();\n    this.collectionModal = new CollectionModal();\n    this.editCollectionModal = new EditCollectionModal();\n\n    // Initialize UI manager with modals\n    UIManager.init({\n      onEditRepository: (repo) => this.editRepositoryModal.open(repo),\n      onEditCollection: (collection) =>\n        this.editCollectionModal.open(collection),\n    });\n\n    // Handle electron API data\n    this.bindElectronEvents();\n\n    console.log(\"👋 OpenMate application initialized successfully\");\n  }\n\n  bindElectronEvents() {\n    if (window.electronAPI && window.electronAPI.onReposData) {\n      window.electronAPI.onReposData((data) => {\n        const { repos = [], collections = [] } = data;\n        AppState.setRepos(repos);\n        AppState.setCollections(collections);\n        UIManager.updateDisplay();\n      });\n    }\n  }\n}\n\n// =======================\n// Initialize Application\n// =======================\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  new App();\n});\n\n// Import styles\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubWF0ZS11aS8uL3NyYy9yZW5kZXJlci5qcz84OGMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTdGF0ZSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgQXBwU3RhdGUgPSB7XG4gIHJlcG9zOiBbXSxcbiAgY29sbGVjdGlvbnM6IFtdLFxuXG4gIHNldFJlcG9zKHJlcG9zKSB7XG4gICAgdGhpcy5yZXBvcyA9IHJlcG9zO1xuICB9LFxuXG4gIHNldENvbGxlY3Rpb25zKGNvbGxlY3Rpb25zKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9ucyA9IGNvbGxlY3Rpb25zO1xuICB9LFxuXG4gIGdldEZpbHRlcmVkUmVwb3Moc2VhcmNoVGVybSkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlckl0ZW1zKHRoaXMucmVwb3MsIHNlYXJjaFRlcm0pO1xuICB9LFxuXG4gIGdldEZpbHRlcmVkQ29sbGVjdGlvbnMoc2VhcmNoVGVybSkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlckl0ZW1zKHRoaXMuY29sbGVjdGlvbnMsIHNlYXJjaFRlcm0pO1xuICB9LFxuXG4gIGZpbHRlckl0ZW1zKGl0ZW1zLCBzZWFyY2hUZXJtKSB7XG4gICAgaWYgKCFzZWFyY2hUZXJtKSByZXR1cm4gaXRlbXM7XG4gICAgY29uc3QgdGVybSA9IHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKFxuICAgICAgKGl0ZW0pID0+XG4gICAgICAgIGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pIHx8XG4gICAgICAgIChpdGVtLnBhdGggJiYgaXRlbS5wYXRoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkpIHx8XG4gICAgICAgIChpdGVtLnJlcG9zICYmIGl0ZW0ucmVwb3MudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSlcbiAgICApO1xuICB9LFxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFV0aWxpdHkgRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgVXRpbHMgPSB7XG4gIGZvcm1hdFBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoID8gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKSA6IFwiXCI7XG4gIH0sXG5cbiAgZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbiBleGVjdXRlZEZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgICB9O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIH07XG4gIH0sXG5cbiAgY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJpYnV0ZXMgPSB7fSwgY2hpbGRyZW4gPSBbXSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzTmFtZVwiKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTdG9yYWdlIE1hbmFnZW1lbnRcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBTdG9yYWdlID0ge1xuICBUSEVNRV9LRVk6IFwib3Blbm1hdGUtdGhlbWVcIixcbiAgSURFX0tFWTogXCJvcGVubWF0ZS1pZGUtc2VsZWN0b3JcIixcblxuICBnZXQoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlN0b3JhZ2UgZ2V0IGZhaWxlZDpcIiwgZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU3RvcmFnZSBzZXQgZmFpbGVkOlwiLCBlKTtcbiAgICB9XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVGhlbWUgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IFRoZW1lTWFuYWdlciA9IHtcbiAgaW5pdCgpIHtcbiAgICB0aGlzLnRoZW1lVG9nZ2xlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0aGVtZS10b2dnbGVcIik7XG4gICAgdGhpcy50aGVtZUljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRoZW1lLWljb25cIik7XG5cbiAgICB0aGlzLmxvYWRUaGVtZSgpO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9LFxuXG4gIGxvYWRUaGVtZSgpIHtcbiAgICBjb25zdCBzYXZlZFRoZW1lID0gU3RvcmFnZS5nZXQoU3RvcmFnZS5USEVNRV9LRVkpO1xuICAgIGNvbnN0IHN5c3RlbVByZWZlcnNEYXJrID0gd2luZG93Lm1hdGNoTWVkaWEoXG4gICAgICBcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIlxuICAgICkubWF0Y2hlcztcbiAgICBjb25zdCB0aGVtZSA9IHNhdmVkVGhlbWUgfHwgKHN5c3RlbVByZWZlcnNEYXJrID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xuXG4gICAgdGhpcy5zZXRUaGVtZSh0aGVtZSk7XG4gIH0sXG5cbiAgc2V0VGhlbWUodGhlbWUpIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10aGVtZVwiLCB0aGVtZSk7XG4gICAgdGhpcy50aGVtZUljb24udGV4dENvbnRlbnQgPSB0aGVtZSA9PT0gXCJkYXJrXCIgPyBcIuKYgO+4j1wiIDogXCLwn4yZXCI7XG4gICAgU3RvcmFnZS5zZXQoU3RvcmFnZS5USEVNRV9LRVksIHRoZW1lKTtcbiAgfSxcblxuICB0b2dnbGUoKSB7XG4gICAgY29uc3QgY3VycmVudFRoZW1lID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGhlbWVcIik7XG4gICAgY29uc3QgbmV3VGhlbWUgPSBjdXJyZW50VGhlbWUgPT09IFwiZGFya1wiID8gXCJsaWdodFwiIDogXCJkYXJrXCI7XG4gICAgdGhpcy5zZXRUaGVtZShuZXdUaGVtZSk7XG4gIH0sXG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLnRoZW1lVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLnRvZ2dsZSgpKTtcbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJREUgU2VsZWN0b3IgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IElERU1hbmFnZXIgPSB7XG4gIGluaXQoKSB7XG4gICAgdGhpcy5zZWxlY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaWRlLXNlbGVjdG9yXCIpO1xuICAgIHRoaXMubG9hZFByZWZlcmVuY2UoKTtcbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfSxcblxuICBsb2FkUHJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBzYXZlZElERSA9IFN0b3JhZ2UuZ2V0KFN0b3JhZ2UuSURFX0tFWSk7XG4gICAgaWYgKHNhdmVkSURFKSB7XG4gICAgICB0aGlzLnNlbGVjdG9yLnZhbHVlID0gc2F2ZWRJREU7XG4gICAgfVxuICB9LFxuXG4gIGdldFNlbGVjdGVkSURFKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdG9yLnZhbHVlO1xuICB9LFxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZElERSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgaWYgKHNlbGVjdGVkSURFKSB7XG4gICAgICAgIFN0b3JhZ2Uuc2V0KFN0b3JhZ2UuSURFX0tFWSwgc2VsZWN0ZWRJREUpO1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKGBEZWZhdWx0IElERSBzZXQgdG8gJHtzZWxlY3RlZElERX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBOb3RpZmljYXRpb24gTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IE5vdGlmaWNhdGlvbk1hbmFnZXIgPSB7XG4gIHNob3cobWVzc2FnZSwgdHlwZSA9IFwiaW5mb1wiLCBkdXJhdGlvbiA9IDMwMDApIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICBzdWNjZXNzOiBcIiM0Q0FGNTBcIixcbiAgICAgIGVycm9yOiBcIiNGNDQzMzZcIixcbiAgICAgIGluZm86IFwiIzIxOTZGM1wiLFxuICAgIH07XG5cbiAgICBjb25zdCBub3RpZmljYXRpb24gPSBVdGlscy5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBib3R0b206IDIwcHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQ6ICR7Y29sb3JzW3R5cGVdfTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlO1xuICAgICAgYCxcbiAgICAgIH0sXG4gICAgICBbbWVzc2FnZV1cbiAgICApO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3RpZmljYXRpb24pO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBub3RpZmljYXRpb24uc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vdGlmaWNhdGlvbikpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vdGlmaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgfSwgZHVyYXRpb24pO1xuICB9LFxuXG4gIHNob3dTdWNjZXNzKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnNob3cobWVzc2FnZSwgXCJzdWNjZXNzXCIpO1xuICB9LFxuXG4gIHNob3dFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KG1lc3NhZ2UsIFwiZXJyb3JcIik7XG4gIH0sXG5cbiAgc2hvd0luZm8obWVzc2FnZSkge1xuICAgIHRoaXMuc2hvdyhtZXNzYWdlLCBcImluZm9cIik7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTW9kYWwgTWFuYWdlbWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IobW9kYWxJZCwgZm9ybUlkLCBvcGVuQnRuSWQpIHtcbiAgICB0aGlzLm1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgdGhpcy5mb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9ybUlkKTtcbiAgICB0aGlzLm9wZW5CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcGVuQnRuSWQpO1xuICAgIHRoaXMuY2xvc2VCdG4gPSB0aGlzLm1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCIuY2xvc2VcIik7XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5vcGVuQnRuPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5vcGVuKCkpO1xuICAgIHRoaXMuY2xvc2VCdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmNsb3NlKCkpO1xuXG4gICAgLy8gQ2xvc2Ugb24gb3V0c2lkZSBjbGlja1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5tb2RhbCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zZSBvbiBFc2NhcGUga2V5XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgdGhpcy5vbk9wZW4oKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMubW9kYWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIjtcbiAgICB0aGlzLmZvcm0/LnJlc2V0KCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kYWwuc3R5bGUuZGlzcGxheSA9PT0gXCJmbGV4XCI7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgLy8gT3ZlcnJpZGUgaW4gc3ViY2xhc3Nlc1xuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICAvLyBPdmVycmlkZSBpbiBzdWJjbGFzc2VzXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFJlcG9zaXRvcnkgTW9kYWxcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBSZXBvc2l0b3J5TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYWRkLXJlcG8tbW9kYWxcIiwgXCJhZGQtcmVwby1mb3JtXCIsIFwiYWRkLXJlcG8tYnRuXCIpO1xuICAgIHRoaXMubmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXBvLW5hbWVcIik7XG4gICAgdGhpcy5wYXRoSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcG8tcGF0aFwiKTtcbiAgICB0aGlzLmJyb3dzZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnJvd3NlLXBhdGhcIik7XG5cbiAgICB0aGlzLmJpbmRSZXBvc2l0b3J5RXZlbnRzKCk7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgdGhpcy5uYW1lSW5wdXQuZm9jdXMoKTtcbiAgfVxuXG4gIGJpbmRSZXBvc2l0b3J5RXZlbnRzKCkge1xuICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChlKSA9PiB0aGlzLmhhbmRsZVN1Ym1pdChlKSk7XG4gICAgdGhpcy5icm93c2VCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuYnJvd3NlUGF0aCgpKTtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVN1Ym1pdChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoSW5wdXQudmFsdWUudHJpbSgpO1xuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5wdXRzKG5hbWUsIHBhdGgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmFkZFJlcG9zaXRvcnkoeyBuYW1lLCBwYXRoIH0pO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhcIlJlcG9zaXRvcnkgYWRkZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcbiAgICAgIFVJTWFuYWdlci5yZWZyZXNoKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3IgYWRkaW5nIHJlcG9zaXRvcnk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlSW5wdXRzKG5hbWUsIHBhdGgpIHtcbiAgICBpZiAoIW5hbWUgfHwgIXBhdGgpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIGZpbGwgaW4gYWxsIGZpZWxkc1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBicm93c2VQYXRoKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXRoID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLm9wZW5EaXJlY3RvcnlEaWFsb2coKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aElucHV0LnZhbHVlID0gcGF0aDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBzZWxlY3RpbmcgZGlyZWN0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEVkaXQgUmVwb3NpdG9yeSBNb2RhbFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIEVkaXRSZXBvc2l0b3J5TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiZWRpdC1yZXBvLW1vZGFsXCIsIFwiZWRpdC1yZXBvLWZvcm1cIik7XG4gICAgdGhpcy5uYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtcmVwby1uYW1lXCIpO1xuICAgIHRoaXMucGF0aElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0LXJlcG8tcGF0aFwiKTtcbiAgICB0aGlzLm9yaWdpbmFsTmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0LW9yaWdpbmFsLW5hbWVcIik7XG4gICAgdGhpcy5icm93c2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtYnJvd3NlLXBhdGhcIik7XG4gICAgdGhpcy5jbG9zZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZWRpdC1yZXBvLW1vZGFsIC5jbG9zZVwiKTtcblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG5cbiAgb3BlbihyZXBvKSB7XG4gICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzXG4gICAgdGhpcy5vcmlnaW5hbE5hbWVJbnB1dC52YWx1ZSA9IHJlcG8ubmFtZTtcblxuICAgIC8vIFNldCBjdXJyZW50IHZhbHVlcyAocmVhZC1vbmx5KVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3VycmVudC1yZXBvLW5hbWVcIikudGV4dENvbnRlbnQgPSByZXBvLm5hbWU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LXJlcG8tcGF0aFwiKS50ZXh0Q29udGVudCA9IHJlcG8ucGF0aDtcblxuICAgIC8vIENsZWFyIGFuZCByZXNldCBmb3JtIGZpZWxkc1xuICAgIHRoaXMubmFtZUlucHV0LnZhbHVlID0gcmVwby5uYW1lO1xuICAgIHRoaXMucGF0aElucHV0LnZhbHVlID0gcmVwby5wYXRoO1xuICAgIHRoaXMubmFtZUlucHV0LnBsYWNlaG9sZGVyID0gYEN1cnJlbnQ6ICR7cmVwby5uYW1lfWA7XG4gICAgdGhpcy5wYXRoSW5wdXQucGxhY2Vob2xkZXIgPSBgQ3VycmVudDogJHtyZXBvLnBhdGh9YDtcblxuICAgIC8vIE9wZW4gbW9kYWwgYW5kIGZvY3VzXG4gICAgc3VwZXIub3BlbigpO1xuICAgIHRoaXMubmFtZUlucHV0LmZvY3VzKCk7XG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuZm9ybT8uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVTdWJtaXQoZSkpO1xuICAgIHRoaXMuYnJvd3NlQnRuPy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5icm93c2VQYXRoKCkpO1xuICAgIHRoaXMuY2xvc2VCdG4/LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmNsb3NlKCkpO1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlU3VibWl0KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSB0aGlzLm9yaWdpbmFsTmFtZUlucHV0LnZhbHVlO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVJbnB1dC52YWx1ZS50cmltKCkgfHwgb3JpZ2luYWxOYW1lOyAvLyBVc2Ugb3JpZ2luYWwgbmFtZSBpZiBuZXcgbmFtZSBpcyBlbXB0eVxuICAgIGNvbnN0IHBhdGggPVxuICAgICAgdGhpcy5wYXRoSW5wdXQudmFsdWUudHJpbSgpIHx8XG4gICAgICB0aGlzLnBhdGhJbnB1dC5wbGFjZWhvbGRlci5yZXBsYWNlKFwiQ3VycmVudDogXCIsIFwiXCIpOyAvLyBVc2UgY3VycmVudCBwYXRoIGlmIGVtcHR5XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVJbnB1dHMobmFtZSwgcGF0aCkpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCByZXBvc2l0b3JpZXMgZGF0YVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcblxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIGV4cGVjdGVkIGRhdGEgc3RydWN0dXJlXG4gICAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgIWRhdGEucmVwb3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXBvc2l0b3J5IGRhdGEgc3RydWN0dXJlXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIkN1cnJlbnQgcmVwb3NpdG9yaWVzOlwiLCBkYXRhLnJlcG9zKTsgLy8gRGVidWcgbG9nXG4gICAgICBjb25zb2xlLmxvZyhcIkxvb2tpbmcgZm9yIHJlcG9zaXRvcnkgd2l0aCBuYW1lOlwiLCBvcmlnaW5hbE5hbWUpOyAvLyBEZWJ1ZyBsb2dcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlcG9zaXRvcnkgZXhpc3RzXG4gICAgICBpZiAoIWRhdGEucmVwb3Nbb3JpZ2luYWxOYW1lXSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVwb3NpdG9yeSBub3QgZm91bmQgaW46XCIsIGRhdGEucmVwb3MpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXBvc2l0b3J5IG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgbmFtZSBpcyBiZWluZyBjaGFuZ2VkIHRvIGFuIGV4aXN0aW5nIG9uZSAoZXhjZXB0IGN1cnJlbnQgcmVwbylcbiAgICAgIGlmIChuYW1lICE9PSBvcmlnaW5hbE5hbWUgJiYgZGF0YS5yZXBvc1tuYW1lXSkge1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgICBcIkEgcmVwb3NpdG9yeSB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5IGV4aXN0c1wiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgcmVwb3NpdG9yaWVzXG4gICAgICBjb25zdCB1cGRhdGVkUmVwb3MgPSB7IC4uLmRhdGEucmVwb3MgfTtcblxuICAgICAgLy8gSWYgbmFtZSBjaGFuZ2VkLCByZW1vdmUgb2xkIGVudHJ5XG4gICAgICBpZiAobmFtZSAhPT0gb3JpZ2luYWxOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkUmVwb3Nbb3JpZ2luYWxOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIG9yIGFkZCB0aGUgcmVwb3NpdG9yeSB3aXRoIG5ldyB2YWx1ZXMgYW5kIHVwZGF0ZWRBdCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIHVwZGF0ZWRSZXBvc1tuYW1lXSA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnJlcG9zW29yaWdpbmFsTmFtZV0/LnVwZGF0ZWRBdCB8fCBub3csXG4gICAgICB9O1xuXG4gICAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIHJlcG9zaXRvcmllcyB1c2luZyB0aGUgY29ycmVjdCBJUEMgbWV0aG9kXG4gICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkud3JpdGVSZXBvc0ZpbGUoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICByZXBvczogdXBkYXRlZFJlcG9zLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlZnJlc2ggVUlcbiAgICAgIFVJTWFuYWdlci5yZWZyZXNoKCk7XG5cbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXCJSZXBvc2l0b3J5IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgcmVwb3NpdG9yeTpcIiwgZXJyb3IpO1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gdXBkYXRlIHJlcG9zaXRvcnk6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlSW5wdXRzKG5hbWUsIHBhdGgpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIGVudGVyIGEgcmVwb3NpdG9yeSBuYW1lXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhIHJlcG9zaXRvcnkgcGF0aFwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBicm93c2VQYXRoKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXRoID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLm9wZW5EaXJlY3RvcnlEaWFsb2coKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aElucHV0LnZhbHVlID0gcGF0aDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXG4gICAgICAgIGBFcnJvciBzZWxlY3RpbmcgZGlyZWN0b3J5OiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEVkaXQgQ29sbGVjdGlvbiBNb2RhbFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIEVkaXRDb2xsZWN0aW9uTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiZWRpdC1jb2xsZWN0aW9uLW1vZGFsXCIsIFwiZWRpdC1jb2xsZWN0aW9uLWZvcm1cIik7XG4gICAgdGhpcy5uYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXQtY29sbGVjdGlvbi1uYW1lXCIpO1xuICAgIHRoaXMub3JpZ2luYWxOYW1lSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgIFwiZWRpdC1vcmlnaW5hbC1jb2xsZWN0aW9uLW5hbWVcIlxuICAgICk7XG4gICAgdGhpcy5jdXJyZW50TmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LWNvbGxlY3Rpb24tbmFtZVwiKTtcbiAgICB0aGlzLmN1cnJlbnRSZXBvc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50LWNvbGxlY3Rpb24tcmVwb3NcIik7XG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZWRpdC1yZXBvcy1zZWxlY3Rpb25cIik7XG4gICAgdGhpcy5jbG9zZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZWRpdC1jb2xsZWN0aW9uLW1vZGFsIC5jbG9zZVwiKTtcblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG5cbiAgYXN5bmMgb3Blbihjb2xsZWN0aW9uKSB7XG4gICAgLy8gU3RvcmUgb3JpZ2luYWwgdmFsdWVzXG4gICAgdGhpcy5vcmlnaW5hbE5hbWVJbnB1dC52YWx1ZSA9IGNvbGxlY3Rpb24ubmFtZTtcblxuICAgIC8vIFNldCBjdXJyZW50IHZhbHVlc1xuICAgIHRoaXMuY3VycmVudE5hbWVFbC50ZXh0Q29udGVudCA9IGNvbGxlY3Rpb24ubmFtZTtcblxuICAgIC8vIEhhbmRsZSBib3RoIGFycmF5IGFuZCBzdHJpbmcgZm9ybWF0cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGNvbnN0IHJlcG9MaXN0ID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uLnJlcG9zKVxuICAgICAgPyBjb2xsZWN0aW9uLnJlcG9zXG4gICAgICA6IChjb2xsZWN0aW9uLnJlcG9zIHx8IFwiXCIpXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5tYXAoKHMpID0+IHMudHJpbSgpKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICB0aGlzLmN1cnJlbnRSZXBvc0VsLnRleHRDb250ZW50ID0gcmVwb0xpc3QubGVuZ3RoXG4gICAgICA/IHJlcG9MaXN0LmpvaW4oXCIsIFwiKVxuICAgICAgOiBcIk5vIHJlcG9zaXRvcmllc1wiO1xuICAgIHRoaXMubmFtZUlucHV0LnZhbHVlID0gY29sbGVjdGlvbi5uYW1lO1xuICAgIHRoaXMubmFtZUlucHV0LnBsYWNlaG9sZGVyID0gYEN1cnJlbnQ6ICR7Y29sbGVjdGlvbi5uYW1lfWA7XG5cbiAgICAvLyBMb2FkIHJlcG9zaXRvcmllcyB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgYXdhaXQgdGhpcy5sb2FkUmVwb3NpdG9yaWVzKHJlcG9MaXN0KTtcblxuICAgIC8vIE9wZW4gbW9kYWwgYW5kIGZvY3VzXG4gICAgc3VwZXIub3BlbigpO1xuICAgIHRoaXMubmFtZUlucHV0LmZvY3VzKCk7XG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuZm9ybT8uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVTdWJtaXQoZSkpO1xuXG4gICAgdGhpcy5jbG9zZUJ0bj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICBhc3luYyBsb2FkUmVwb3NpdG9yaWVzKHNlbGVjdGVkUmVwb3MgPSBbXSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZXBvc2l0b3J5U2VsZWN0aW9uKGRhdGEucmVwb3MgfHwge30sIHNlbGVjdGVkUmVwb3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJlcnJvclwiPkVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzLiBQbGVhc2UgdHJ5IGFnYWluLjwvZGl2Pic7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyUmVwb3NpdG9yeVNlbGVjdGlvbihyZXBvcywgc2VsZWN0ZWRSZXBvcyA9IFtdKSB7XG4gICAgaWYgKCFyZXBvcyB8fCBPYmplY3Qua2V5cyhyZXBvcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJlcG9zU2VsZWN0aW9uLmlubmVySFRNTCA9XG4gICAgICAgICc8ZGl2IGNsYXNzPVwibG9hZGluZ1wiPk5vIHJlcG9zaXRvcmllcyBmb3VuZC4gQWRkIHJlcG9zaXRvcmllcyBmaXJzdC48L2Rpdj4nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcG9zTGlzdCA9IE9iamVjdC5lbnRyaWVzKHJlcG9zKVxuICAgICAgLnNvcnQoKFtuYW1lQV0sIFtuYW1lQl0pID0+IG5hbWVBLmxvY2FsZUNvbXBhcmUobmFtZUIpKVxuICAgICAgLm1hcChcbiAgICAgICAgKFtuYW1lLCByZXBvXSkgPT4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwicmVwby1jaGVja2JveC1pdGVtXCI+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZWRpdC1yZXBvLSR7bmFtZX1cIiBuYW1lPVwicmVwb3NcIiB2YWx1ZT1cIiR7bmFtZX1cIiBcbiAgICAgICAgICAgICAgICAgJHtzZWxlY3RlZFJlcG9zLmluY2x1ZGVzKG5hbWUpID8gXCJjaGVja2VkXCIgOiBcIlwifT5cbiAgICAgICAgICA8bGFiZWwgZm9yPVwiZWRpdC1yZXBvLSR7bmFtZX1cIj5cbiAgICAgICAgICAgIDxzcGFuPiR7bmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlcG8tcGF0aFwiPiR7cmVwby5wYXRofTwvc3Bhbj5cbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICAgIClcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPSByZXBvc0xpc3Q7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IHRoaXMub3JpZ2luYWxOYW1lSW5wdXQudmFsdWU7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBjb25zdCBzZWxlY3RlZFJlcG9zID0gdGhpcy5nZXRTZWxlY3RlZFJlcG9zaXRvcmllcygpO1xuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5wdXRzKG5hbWUsIHNlbGVjdGVkUmVwb3MpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5nZXRSZXBvc0RhdGEoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgbmFtZSBpcyBiZWluZyBjaGFuZ2VkIHRvIGFuIGV4aXN0aW5nIG9uZSAoZXhjZXB0IGN1cnJlbnQgY29sbGVjdGlvbilcbiAgICAgIGlmIChuYW1lICE9PSBvcmlnaW5hbE5hbWUgJiYgZGF0YS5jb2xsZWN0aW9ucyAmJiBkYXRhLmNvbGxlY3Rpb25zW25hbWVdKSB7XG4gICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICAgIFwiQSBjb2xsZWN0aW9uIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uc1xuICAgICAgY29uc3QgdXBkYXRlZENvbGxlY3Rpb25zID0geyAuLi5kYXRhLmNvbGxlY3Rpb25zIH07XG5cbiAgICAgIC8vIFJlbW92ZSBvbGQgZW50cnkgaWYgbmFtZSBjaGFuZ2VkXG4gICAgICBpZiAobmFtZSAhPT0gb3JpZ2luYWxOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkQ29sbGVjdGlvbnNbb3JpZ2luYWxOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIG9yIGFkZCB0aGUgY29sbGVjdGlvbiB3aXRoIG5ldyB2YWx1ZXNcbiAgICAgIHVwZGF0ZWRDb2xsZWN0aW9uc1tuYW1lXSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmVwb3M6IHNlbGVjdGVkUmVwb3MsIC8vIFNhdmUgYXMgYXJyYXlcbiAgICAgICAgdXBkYXRlZEF0OlxuICAgICAgICAgIHVwZGF0ZWRDb2xsZWN0aW9uc1tvcmlnaW5hbE5hbWVdPy51cGRhdGVkQXQgfHxcbiAgICAgICAgICBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIGNvbGxlY3Rpb25zXG4gICAgICBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkud3JpdGVSZXBvc0ZpbGUoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjb2xsZWN0aW9uczogdXBkYXRlZENvbGxlY3Rpb25zLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoXCJDb2xsZWN0aW9uIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgVUlNYW5hZ2VyLnJlZnJlc2goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwZGF0aW5nIGNvbGxlY3Rpb246XCIsIGVycm9yKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHVwZGF0ZSBjb2xsZWN0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXRTZWxlY3RlZFJlcG9zaXRvcmllcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnKVxuICAgICkubWFwKChjaGVja2JveCkgPT4gY2hlY2tib3gudmFsdWUpO1xuICB9XG5cbiAgdmFsaWRhdGVJbnB1dHMobmFtZSwgc2VsZWN0ZWRSZXBvcykge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoXCJQbGVhc2UgZW50ZXIgYSBjb2xsZWN0aW9uIG5hbWVcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkUmVwb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIHJlcG9zaXRvcnlcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbGxlY3Rpb24gTW9kYWxcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBDb2xsZWN0aW9uTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYWRkLWNvbGxlY3Rpb24tbW9kYWxcIiwgXCJhZGQtY29sbGVjdGlvbi1mb3JtXCIsIFwiYWRkLWNvbGxlY3Rpb24tYnRuXCIpO1xuICAgIHRoaXMubmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb2xsZWN0aW9uLW5hbWVcIik7XG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwb3Mtc2VsZWN0aW9uXCIpO1xuXG4gICAgdGhpcy5iaW5kQ29sbGVjdGlvbkV2ZW50cygpO1xuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIHRoaXMubmFtZUlucHV0LmZvY3VzKCk7XG4gICAgYXdhaXQgdGhpcy5sb2FkUmVwb3NpdG9yaWVzKCk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICc8ZGl2IGNsYXNzPVwibG9hZGluZ1wiPkxvYWRpbmcgcmVwb3NpdG9yaWVzLi4uPC9kaXY+JztcbiAgfVxuXG4gIGJpbmRDb2xsZWN0aW9uRXZlbnRzKCkge1xuICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChlKSA9PiB0aGlzLmhhbmRsZVN1Ym1pdChlKSk7XG4gIH1cblxuICBhc3luYyBsb2FkUmVwb3NpdG9yaWVzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZXBvc2l0b3J5U2VsZWN0aW9uKGRhdGEucmVwb3MgfHwge30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVwb3NTZWxlY3Rpb24uaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJlcnJvclwiPkVycm9yIGxvYWRpbmcgcmVwb3NpdG9yaWVzLiBQbGVhc2UgdHJ5IGFnYWluLjwvZGl2Pic7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyUmVwb3NpdG9yeVNlbGVjdGlvbihyZXBvcykge1xuICAgIGlmICghcmVwb3MgfHwgT2JqZWN0LmtleXMocmVwb3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPVxuICAgICAgICAnPGRpdiBjbGFzcz1cImxvYWRpbmdcIj5ObyByZXBvc2l0b3JpZXMgZm91bmQuIEFkZCByZXBvc2l0b3JpZXMgZmlyc3QuPC9kaXY+JztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXBvc0xpc3QgPSBPYmplY3QuZW50cmllcyhyZXBvcylcbiAgICAgIC5zb3J0KChbbmFtZUFdLCBbbmFtZUJdKSA9PiBuYW1lQS5sb2NhbGVDb21wYXJlKG5hbWVCKSlcbiAgICAgIC5tYXAoXG4gICAgICAgIChbbmFtZSwgcmVwb10pID0+IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInJlcG8tY2hlY2tib3gtaXRlbVwiPlxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInJlcG8tJHtuYW1lfVwiIG5hbWU9XCJyZXBvc1wiIHZhbHVlPVwiJHtuYW1lfVwiPlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZXBvLSR7bmFtZX1cIj5cbiAgICAgICAgICAgIDxzcGFuPiR7bmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlcG8tcGF0aFwiPiR7cmVwby5wYXRofTwvc3Bhbj5cbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICAgIClcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5pbm5lckhUTUwgPSByZXBvc0xpc3Q7XG4gIH1cblxuICBhc3luYyBoYW5kbGVTdWJtaXQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRSZXBvcyA9IHRoaXMuZ2V0U2VsZWN0ZWRSZXBvc2l0b3JpZXMoKTtcblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cyhuYW1lLCBzZWxlY3RlZFJlcG9zKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZUNvbGxlY3Rpb24obmFtZSwgc2VsZWN0ZWRSZXBvcyk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFwiQ29sbGVjdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseSFcIik7XG4gICAgICBVSU1hbmFnZXIucmVmcmVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcbiAgICAgICAgYEVycm9yIGNyZWF0aW5nIGNvbGxlY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGdldFNlbGVjdGVkUmVwb3NpdG9yaWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKFxuICAgICAgdGhpcy5yZXBvc1NlbGVjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl06Y2hlY2tlZCcpXG4gICAgKS5tYXAoKGNoZWNrYm94KSA9PiBjaGVja2JveC52YWx1ZSk7XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0cyhuYW1lLCBzZWxlY3RlZFJlcG9zKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihcIlBsZWFzZSBlbnRlciBhIGNvbGxlY3Rpb24gbmFtZVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRSZXBvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgcmVwb3NpdG9yeVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHNhdmVDb2xsZWN0aW9uKG5hbWUsIHNlbGVjdGVkUmVwb3MpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuXG4gICAgaWYgKGRhdGEuY29sbGVjdGlvbnMgJiYgZGF0YS5jb2xsZWN0aW9uc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBjb2xsZWN0aW9uIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIH1cblxuICAgIGlmICghZGF0YS5jb2xsZWN0aW9ucykgZGF0YS5jb2xsZWN0aW9ucyA9IHt9O1xuICAgIGRhdGEuY29sbGVjdGlvbnNbbmFtZV0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVwb3M6IHNlbGVjdGVkUmVwb3MsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLndyaXRlUmVwb3NGaWxlKGRhdGEpO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVSSBNYW5hZ2VtZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgVUlNYW5hZ2VyID0ge1xuICBpbml0KGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgdGhpcy5zZWFyY2hJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoLWlucHV0XCIpO1xuICAgIHRoaXMucmVmcmVzaEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVmcmVzaC1idG5cIik7XG5cbiAgICAvLyBTdG9yZSBjYWxsYmFja3NcbiAgICB0aGlzLmhhbmRsZUVkaXRSZXBvc2l0b3J5ID0gY2FsbGJhY2tzLm9uRWRpdFJlcG9zaXRvcnkgfHwgKCgpID0+IHt9KTtcbiAgICB0aGlzLmhhbmRsZUVkaXRDb2xsZWN0aW9uID0gY2FsbGJhY2tzLm9uRWRpdENvbGxlY3Rpb24gfHwgKCgpID0+IHt9KTtcblxuICAgIC8vIEluaXRpYWxpemUgZWRpdCBjb2xsZWN0aW9uIG1vZGFsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIXRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbCkge1xuICAgICAgdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsID0gbmV3IEVkaXRDb2xsZWN0aW9uTW9kYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfSxcblxuICBiaW5kRXZlbnRzKCkge1xuICAgIC8vIERlYm91bmNlIHNlYXJjaCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG4gICAgY29uc3QgZGVib3VuY2VkVXBkYXRlID0gVXRpbHMuZGVib3VuY2UoKCkgPT4gdGhpcy51cGRhdGVEaXNwbGF5KCksIDMwMCk7XG4gICAgdGhpcy5zZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZGVib3VuY2VkVXBkYXRlKTtcbiAgICB0aGlzLnJlZnJlc2hCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMucmVmcmVzaCgpKTtcbiAgfSxcblxuICBhc3luYyByZWZyZXNoKCkge1xuICAgIHRoaXMuc2hvd1JlZnJlc2hBbmltYXRpb24oKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmdldFJlcG9zRGF0YSgpO1xuICAgICAgdGhpcy5wcm9jZXNzRGF0YShkYXRhKTtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihgRXJyb3IgcmVmcmVzaGluZyBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaGlkZVJlZnJlc2hBbmltYXRpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJvY2Vzc0RhdGEoZGF0YSkge1xuICAgIC8vIFByb2Nlc3MgcmVwb3NpdG9yaWVzXG4gICAgaWYgKGRhdGEucmVwb3MpIHtcbiAgICAgIGNvbnN0IHJlcG9zID0gT2JqZWN0LmVudHJpZXMoZGF0YS5yZXBvcykubWFwKChbbmFtZSwgcmVwb10pID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHBhdGg6IHJlcG8ucGF0aCxcbiAgICAgICAgdXBkYXRlZEF0OiByZXBvLnVwZGF0ZWRBdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KSk7XG4gICAgICBBcHBTdGF0ZS5zZXRSZXBvcyhyZXBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFwcFN0YXRlLnNldFJlcG9zKFtdKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGNvbGxlY3Rpb25zXG4gICAgaWYgKGRhdGEuY29sbGVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb25zID0gT2JqZWN0LnZhbHVlcyhkYXRhLmNvbGxlY3Rpb25zKS5tYXAoKGNvbGxlY3Rpb24pID0+ICh7XG4gICAgICAgIG5hbWU6IGNvbGxlY3Rpb24ubmFtZSxcbiAgICAgICAgcmVwb3M6IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbi5yZXBvcylcbiAgICAgICAgICA/IGNvbGxlY3Rpb24ucmVwb3Muam9pbihcIiwgXCIpXG4gICAgICAgICAgOiBcIlwiLFxuICAgICAgICB1cGRhdGVkQXQ6IGNvbGxlY3Rpb24udXBkYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pKTtcbiAgICAgIEFwcFN0YXRlLnNldENvbGxlY3Rpb25zKGNvbGxlY3Rpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQXBwU3RhdGUuc2V0Q29sbGVjdGlvbnMoW10pO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVEaXNwbGF5KCkge1xuICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRyaW0oKTtcbiAgICB0aGlzLnVwZGF0ZVJlcG9zaXRvcmllc1RhYmxlKEFwcFN0YXRlLmdldEZpbHRlcmVkUmVwb3Moc2VhcmNoVGVybSkpO1xuICAgIHRoaXMudXBkYXRlQ29sbGVjdGlvbnNUYWJsZShBcHBTdGF0ZS5nZXRGaWx0ZXJlZENvbGxlY3Rpb25zKHNlYXJjaFRlcm0pKTtcbiAgfSxcblxuICB1cGRhdGVSZXBvc2l0b3JpZXNUYWJsZShyZXBvcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwb3MtbGlzdFwiKTtcbiAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVwb3MtdGFibGVcIik7XG4gICAgY29uc3QgbG9hZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1yZXBvc1wiKTtcblxuICAgIGlmIChyZXBvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvYWRpbmcudGV4dENvbnRlbnQgPSBcIk5vIG1hdGNoaW5nIHJlcG9zaXRvcmllcyBmb3VuZC5cIjtcbiAgICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRhYmxlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB0YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZVwiO1xuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHJlcG9zXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSlcbiAgICAgIC5tYXAoKHJlcG8pID0+IHRoaXMuY3JlYXRlUmVwb3NpdG9yeVJvdyhyZXBvKSlcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5iaW5kUmVwb3NpdG9yeUV2ZW50cygpO1xuICB9LFxuXG4gIGNyZWF0ZVJlcG9zaXRvcnlSb3cocmVwbykge1xuICAgIHJldHVybiBgXG4gICAgICA8dHIgZGF0YS1wYXRoPVwiJHtVdGlscy5mb3JtYXRQYXRoKHJlcG8ucGF0aCl9XCIgY2xhc3M9XCJjbGlja2FibGUtcmVwby1yb3dcIj5cbiAgICAgICAgPHRkPjxzdHJvbmc+JHtyZXBvLm5hbWV9PC9zdHJvbmc+PC90ZD5cbiAgICAgICAgPHRkIGNsYXNzPVwicGF0aFwiPiR7VXRpbHMuZm9ybWF0UGF0aChyZXBvLnBhdGgpfTwvdGQ+XG4gICAgICAgIDx0ZCBjbGFzcz1cImFjdGlvbnNcIj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZ2FwOiA1cHhcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJlZGl0LWJ0blwiIGRhdGEtbmFtZT1cIiR7cmVwby5uYW1lfVwiIGRhdGEtcGF0aD1cIiR7VXRpbHMuZm9ybWF0UGF0aChyZXBvLnBhdGgpfVwiIGRhdGEtdHlwZT1cInJlcG9cIiB0aXRsZT1cIkVkaXQgcmVwb3NpdG9yeVwiPuKcj++4jzwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZS1idG5cIiBkYXRhLW5hbWU9XCIke3JlcG8ubmFtZX1cIiBkYXRhLXR5cGU9XCJyZXBvXCIgdGl0bGU9XCJEZWxldGUgcmVwb3NpdG9yeVwiPvCfl5HvuI88L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvdHI+XG4gICAgYDtcbiAgfSxcblxuICBiaW5kUmVwb3NpdG9yeUV2ZW50cygpIHtcbiAgICAvLyBCaW5kIGNsaWNrIGV2ZW50cyBmb3Igb3BlbmluZyByZXBvc2l0b3JpZXNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNsaWNrYWJsZS1yZXBvLXJvd1wiKS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMuaGFuZGxlUmVwb3NpdG9yeUNsaWNrKGUsIHJvdykpO1xuICAgIH0pO1xuXG4gICAgLy8gQmluZCBlZGl0IGV2ZW50c1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5lZGl0LWJ0bltkYXRhLXR5cGU9XCJyZXBvXCJdJykuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBidG4uZGF0YXNldC5uYW1lO1xuICAgICAgICBjb25zdCBwYXRoID0gYnRuLmRhdGFzZXQucGF0aDtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlRWRpdFJlcG9zaXRvcnkpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVkaXRSZXBvc2l0b3J5KHsgbmFtZSwgcGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGRlbGV0ZSBldmVudHNcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZWxldGUtYnRuW2RhdGEtdHlwZT1cInJlcG9cIl0nKVxuICAgICAgLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PlxuICAgICAgICAgIHRoaXMuaGFuZGxlUmVwb3NpdG9yeURlbGV0ZShlLCBidG4pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgfSxcblxuICBhc3luYyBoYW5kbGVSZXBvc2l0b3J5Q2xpY2soZSwgcm93KSB7XG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQlVUVE9OXCIpIHJldHVybjtcblxuICAgIGNvbnN0IHNlbGVjdGVkSURFID0gSURFTWFuYWdlci5nZXRTZWxlY3RlZElERSgpO1xuICAgIGlmICghc2VsZWN0ZWRJREUpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFwiUGxlYXNlIHNlbGVjdCBhbiBJREUgZmlyc3RcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVwb1BhdGggPSByb3cuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYXRoXCIpO1xuICAgIGNvbnN0IHJlcG9OYW1lID0gcm93LmdldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiKTtcbiAgICBjb25zb2xlLmxvZyhyZXBvUGF0aCwgcmVwb05hbWUpO1xuICAgIGlmICghcmVwb1BhdGgpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkub3BlbkluSURFKHtcbiAgICAgICAgbmFtZTogcm93LmdldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiKSxcbiAgICAgICAgcGF0aDogcmVwb1BhdGgsXG4gICAgICAgIGlkZTogc2VsZWN0ZWRJREUsXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yIHx8IFwiRmFpbGVkIHRvIG9wZW4gaW4gSURFXCIpO1xuICAgICAgfVxuXG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKFxuICAgICAgICBgU3VjY2Vzc2Z1bGx5IG9wZW5lZCAke3JlcG9QYXRofSBpbiAke3NlbGVjdGVkSURFfWBcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKGBFcnJvciBvcGVuaW5nIElERTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfSxcblxuICBhc3luYyBoYW5kbGVSZXBvc2l0b3J5RGVsZXRlKGUsIGJ0bikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBuYW1lID0gYnRuLmdldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiKTtcbiAgICAvLyBpZiAoIWNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgcmVwb3NpdG9yeSBcIiR7bmFtZX1cIj9gKSlcbiAgICAvLyAgIHJldHVybjtcblxuICAgIGNvbnN0IGxvYWRpbmdFbCA9IHRoaXMuc2hvd0xvYWRpbmdJbmRpY2F0b3IoXCJEZWxldGluZy4uLlwiKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZGVsZXRlUmVwbyhuYW1lKTtcblxuICAgICAgaWYgKHJlc3VsdD8uc3VjY2Vzcykge1xuICAgICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dTdWNjZXNzKGBTdWNjZXNzZnVsbHkgZGVsZXRlZCAke25hbWV9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdD8uZXJyb3IgfHwgXCJVbmtub3duIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLnNob3dFcnJvcihgRXJyb3IgZGVsZXRpbmcgJHtuYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmhpZGVMb2FkaW5nSW5kaWNhdG9yKGxvYWRpbmdFbCk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZUNvbGxlY3Rpb25zVGFibGUoY29sbGVjdGlvbnMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbGxlY3Rpb25zLWxpc3RcIik7XG4gICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbGxlY3Rpb25zLXRhYmxlXCIpO1xuICAgIGNvbnN0IGxvYWRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmctY29sbGVjdGlvbnNcIik7XG5cbiAgICBpZiAoY29sbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2FkaW5nLnRleHRDb250ZW50ID0gXCJObyBtYXRjaGluZyBjb2xsZWN0aW9ucyBmb3VuZC5cIjtcbiAgICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRhYmxlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB0YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZVwiO1xuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGNvbGxlY3Rpb25zXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSlcbiAgICAgIC5tYXAoKGNvbGxlY3Rpb24pID0+IHRoaXMuY3JlYXRlQ29sbGVjdGlvblJvdyhjb2xsZWN0aW9uKSlcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5iaW5kQ29sbGVjdGlvbkV2ZW50cygpO1xuICB9LFxuXG4gIGNyZWF0ZUNvbGxlY3Rpb25Sb3coY29sbGVjdGlvbikge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25EYXRhID0gSlNPTi5zdHJpbmdpZnkoY29sbGVjdGlvbikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIik7XG4gICAgcmV0dXJuIGBcbiAgICAgIDx0ciBjbGFzcz1cImNsaWNrYWJsZS1jb2xsZWN0aW9uLXJvd1wiIGRhdGEtY29sbGVjdGlvbj1cIiR7Y29sbGVjdGlvbkRhdGF9XCI+XG4gICAgICAgIDx0ZD48c3Ryb25nPiR7Y29sbGVjdGlvbi5uYW1lfTwvc3Ryb25nPjwvdGQ+XG4gICAgICAgIDx0ZD4ke2NvbGxlY3Rpb24ucmVwb3N9PC90ZD5cbiAgICAgICAgPHRkIGNsYXNzPVwiYWN0aW9uc1wiPlxuICAgICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBnYXA6IDVweFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImVkaXQtYnRuXCIgZGF0YS1uYW1lPVwiJHtjb2xsZWN0aW9uLm5hbWV9XCIgZGF0YS10eXBlPVwiY29sbGVjdGlvblwiIHRpdGxlPVwiRWRpdCBjb2xsZWN0aW9uXCI+4pyP77iPPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZGVsZXRlLWJ0blwiIGRhdGEtbmFtZT1cIiR7Y29sbGVjdGlvbi5uYW1lfVwiIGRhdGEtdHlwZT1cImNvbGxlY3Rpb25cIiB0aXRsZT1cIkRlbGV0ZSBjb2xsZWN0aW9uXCI+8J+Xke+4jzwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3RkPlxuICAgICAgPC90cj5cbiAgICBgO1xuICB9LFxuXG4gIGJpbmRDb2xsZWN0aW9uRXZlbnRzKCkge1xuICAgIC8vIEJpbmQgY2xpY2sgZXZlbnRzIGZvciBvcGVuaW5nIGNvbGxlY3Rpb25zXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jbGlja2FibGUtY29sbGVjdGlvbi1yb3dcIikuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICByb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB0aGlzLmhhbmRsZUNvbGxlY3Rpb25DbGljayhlLCByb3cpKTtcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgZWRpdCBldmVudHNcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5lZGl0LWJ0bltkYXRhLXR5cGU9XCJjb2xsZWN0aW9uXCJdJylcbiAgICAgIC5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgY29uc3QgY29sbGVjdGlvbkRhdGEgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgYnRuXG4gICAgICAgICAgICAgIC5jbG9zZXN0KFwidHJcIilcbiAgICAgICAgICAgICAgLmdldEF0dHJpYnV0ZShcImRhdGEtY29sbGVjdGlvblwiKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb2xsZWN0aW9uTW9kYWwub3Blbihjb2xsZWN0aW9uRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgLy8gQmluZCBkZWxldGUgZXZlbnRzXG4gICAgZG9jdW1lbnRcbiAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVsZXRlLWJ0bltkYXRhLXR5cGU9XCJjb2xsZWN0aW9uXCJdJylcbiAgICAgIC5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT5cbiAgICAgICAgICB0aGlzLmhhbmRsZUNvbGxlY3Rpb25EZWxldGUoZSwgYnRuKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgYXN5bmMgaGFuZGxlQ29sbGVjdGlvbkNsaWNrKGUsIHJvdykge1xuICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIkJVVFRPTlwiKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29sbGVjdGlvbiA9IEpTT04ucGFyc2Uocm93LmdldEF0dHJpYnV0ZShcImRhdGEtY29sbGVjdGlvblwiKSk7XG4gICAgICBjb25zdCByZXBvc0RhdGEgPSBhd2FpdCB3aW5kb3cuZWxlY3Ryb25BUEkuZ2V0UmVwb3NEYXRhKCk7XG5cbiAgICAgIGNvbnN0IHJlcG9zID0gY29sbGVjdGlvbi5yZXBvcy5zcGxpdChcIixcIikubWFwKChyZXBvKSA9PiB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCBwYXRoLCBpZGVdID0gcmVwb1xuICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAuc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpO1xuICAgICAgICByZXR1cm4geyBuYW1lLCBwYXRoLCBpZGUgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPcGVuIGFsbCByZXBvc2l0b3JpZXMgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnN0IHByb21pc2VzID0gcmVwb3MubWFwKGFzeW5jIChyZXBvKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcG9EYXRhID0gcmVwb3NEYXRhLnJlcG9zW3JlcG8ubmFtZV07XG5cbiAgICAgICAgaWYgKCFyZXBvRGF0YSkge1xuICAgICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICAgICAgYCR7cmVwby5uYW1lfTogTm90IGZvdW5kIGluIHJlcG9zaXRvcmllc2BcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkZSA9IHJlcG8uaWRlIHx8IElERU1hbmFnZXIuZ2V0U2VsZWN0ZWRJREUoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdpbmRvdy5lbGVjdHJvbkFQSS5vcGVuSW5JREUoe1xuICAgICAgICAgICAgbmFtZTogcmVwby5uYW1lLFxuICAgICAgICAgICAgcGF0aDogcmVwb0RhdGEucGF0aCxcbiAgICAgICAgICAgIGlkZTogaWRlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBvcGVuICR7cmVwby5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd1N1Y2Nlc3MoYFN1Y2Nlc3NmdWxseSBvcGVuZWQgJHtjb2xsZWN0aW9uLm5hbWV9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIE5vdGlmaWNhdGlvbk1hbmFnZXIuc2hvd0Vycm9yKFxuICAgICAgICBgRXJyb3IgcHJvY2Vzc2luZyBjb2xsZWN0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgYXN5bmMgaGFuZGxlQ29sbGVjdGlvbkRlbGV0ZShlLCBidG4pIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3QgbmFtZSA9IGJ0bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5hbWVcIik7XG4gICAgLy8gaWYgKCFjb25maXJtKGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIGNvbGxlY3Rpb24gXCIke25hbWV9XCI/YCkpXG4gICAgLy8gICByZXR1cm47XG5cbiAgICBjb25zdCBsb2FkaW5nRWwgPSB0aGlzLnNob3dMb2FkaW5nSW5kaWNhdG9yKFwiRGVsZXRpbmcuLi5cIik7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2luZG93LmVsZWN0cm9uQVBJLmRlbGV0ZUNvbGxlY3Rpb24obmFtZSk7XG5cbiAgICAgIGlmIChyZXN1bHQ/LnN1Y2Nlc3MpIHtcbiAgICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93U3VjY2VzcyhgU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgJHtuYW1lfWApO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQ/LmVycm9yIHx8IFwiVW5rbm93biBlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlci5zaG93RXJyb3IoYEVycm9yIGRlbGV0aW5nICR7bmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5oaWRlTG9hZGluZ0luZGljYXRvcihsb2FkaW5nRWwpO1xuICAgIH1cbiAgfSxcblxuICBzaG93UmVmcmVzaEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLnJlZnJlc2hCdG4uY2xhc3NMaXN0LmFkZChcInJvdGF0aW5nXCIpO1xuICB9LFxuXG4gIGhpZGVSZWZyZXNoQW5pbWF0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZWZyZXNoQnRuLmNsYXNzTGlzdC5yZW1vdmUoXCJyb3RhdGluZ1wiKTtcbiAgICB9LCAxMDAwKTtcbiAgfSxcblxuICBzaG93TG9hZGluZ0luZGljYXRvcih0ZXh0KSB7XG4gICAgY29uc3QgaW5kaWNhdG9yID0gVXRpbHMuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAxMHB4O1xuICAgICAgICByaWdodDogMTBweDtcbiAgICAgICAgcGFkZGluZzogMTBweDtcbiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjcpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgei1pbmRleDogMTAwMDtcbiAgICAgIGAsXG4gICAgICB9LFxuICAgICAgW3RleHRdXG4gICAgKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICByZXR1cm4gaW5kaWNhdG9yO1xuICB9LFxuXG4gIGhpZGVMb2FkaW5nSW5kaWNhdG9yKGluZGljYXRvcikge1xuICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGluZGljYXRvcikpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICB9XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQXBwbGljYXRpb24gSW5pdGlhbGl6YXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5jbGFzcyBBcHAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBjb3JlIHN5c3RlbXNcbiAgICBUaGVtZU1hbmFnZXIuaW5pdCgpO1xuICAgIElERU1hbmFnZXIuaW5pdCgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtb2RhbHNcbiAgICB0aGlzLnJlcG9zaXRvcnlNb2RhbCA9IG5ldyBSZXBvc2l0b3J5TW9kYWwoKTtcbiAgICB0aGlzLmVkaXRSZXBvc2l0b3J5TW9kYWwgPSBuZXcgRWRpdFJlcG9zaXRvcnlNb2RhbCgpO1xuICAgIHRoaXMuY29sbGVjdGlvbk1vZGFsID0gbmV3IENvbGxlY3Rpb25Nb2RhbCgpO1xuICAgIHRoaXMuZWRpdENvbGxlY3Rpb25Nb2RhbCA9IG5ldyBFZGl0Q29sbGVjdGlvbk1vZGFsKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIFVJIG1hbmFnZXIgd2l0aCBtb2RhbHNcbiAgICBVSU1hbmFnZXIuaW5pdCh7XG4gICAgICBvbkVkaXRSZXBvc2l0b3J5OiAocmVwbykgPT4gdGhpcy5lZGl0UmVwb3NpdG9yeU1vZGFsLm9wZW4ocmVwbyksXG4gICAgICBvbkVkaXRDb2xsZWN0aW9uOiAoY29sbGVjdGlvbikgPT5cbiAgICAgICAgdGhpcy5lZGl0Q29sbGVjdGlvbk1vZGFsLm9wZW4oY29sbGVjdGlvbiksXG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgZWxlY3Ryb24gQVBJIGRhdGFcbiAgICB0aGlzLmJpbmRFbGVjdHJvbkV2ZW50cygpO1xuXG4gICAgY29uc29sZS5sb2coXCLwn5GLIE9wZW5NYXRlIGFwcGxpY2F0aW9uIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgfVxuXG4gIGJpbmRFbGVjdHJvbkV2ZW50cygpIHtcbiAgICBpZiAod2luZG93LmVsZWN0cm9uQVBJICYmIHdpbmRvdy5lbGVjdHJvbkFQSS5vblJlcG9zRGF0YSkge1xuICAgICAgd2luZG93LmVsZWN0cm9uQVBJLm9uUmVwb3NEYXRhKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVwb3MgPSBbXSwgY29sbGVjdGlvbnMgPSBbXSB9ID0gZGF0YTtcbiAgICAgICAgQXBwU3RhdGUuc2V0UmVwb3MocmVwb3MpO1xuICAgICAgICBBcHBTdGF0ZS5zZXRDb2xsZWN0aW9ucyhjb2xsZWN0aW9ucyk7XG4gICAgICAgIFVJTWFuYWdlci51cGRhdGVEaXNwbGF5KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEluaXRpYWxpemUgQXBwbGljYXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIG5ldyBBcHAoKTtcbn0pO1xuXG4vLyBJbXBvcnQgc3R5bGVzXG5pbXBvcnQgXCIuL2luZGV4LmNzc1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/renderer.js\n\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("8ac6b25182f61cef1f70")
/******/ })();
/******/ 
/******/ }
);